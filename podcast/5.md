---
title: "Episode 5: Luke Hoban, CTO of Pulumi, co-founder of TypeScript"
publishDate: 2020-07-13T10:01-07:00
tags: [podcast]
slug: luke-hoban
published: true
---

<!-- START AUDIO -->
<audio className="object-center" src="https://www.buzzsprout.com/1097978/4466138-luke-hoban-cto-of-pulumi-co-founder-of-typescript.mp3" controls={true} preload="none"></audio>
<!-- END AUDIO -->

<!-- START GUESTS -->
<span>
Luke Hoban, Beyang Liu
</span>
<!-- END GUESTS -->

<!-- START SUMMARY -->
If you write code on the modern web, it's almost certain that your life has been shaped significantly by [Luke Hoban's](https://twitter.com/lukehoban) work. Luke has worked on developer tools his entire career. He started out on Visual Studio, C#, and .NET in the early 2000s, later joined the ECMAScript standards body as a representative of Microsoft, and then became one of the co-founders of the TypeScript programming language. Today, he is the CTO of Pulumi, an infrastructure-as-code company that lets you write your deployment config as code in your favorite language.

Luke shares stories from the early days of TypeScript and talks about how it evolved from a two-man team to one of the most successful programming languages and open-source projects. We discuss important inflection points and design decisions that played a key role in TypeScript's runaway success. We also dive into the symbiotic relationship that TypeScript had with another early project just getting off the ground at the time: VS Code. Luke also shares his learnings from his stint at AWS, how his role at Pulumi combines his two passions for programming languages and cloud infrastructure, and how Pulumi brings the niceties of the IDE experience to an area that sorely needs itâ€”infrastructure configuration management.
<!-- END SUMMARY -->

<!-- START SHOWNOTES -->
Luke Hoban: https://twitter.com/lukehoban

Pulumi: https://www.pulumi.com/, https://twitter.com/PulumiCorp

Joe Duffy, founder and CEO of Pulumi: https://twitter.com/funcOfJoe

Q Basic: https://en.wikipedia.org/wiki/QBasic

Gorilla.BAS and Nibbles.BAS: https://en.wikipedia.org/wiki/Gorillas_(video_game), https://en.wikipedia.org/wiki/Nibbles_(video_game)

C#: https://en.wikipedia.org/wiki/C_Sharp_(programming_language)

.NET: https://en.wikipedia.org/wiki/.NET_Framework

Visual Basic: https://en.wikipedia.org/wiki/Visual_Basic

Chakra JavaScript engine: https://en.wikipedia.org/wiki/Chakra_(JScript_engine)

V8 JavaSCript engine: https://en.wikipedia.org/wiki/V8_(JavaScript_engine)

Steve Lucco, Technical Fellow at Microsoft, co-founder of TypeScript: https://www.linkedin.com/in/steve-lucco-b5084958/

Google's JavaScript Closure Compiler: https://developers.google.com/closure/compiler

Visual Studio: https://en.wikipedia.org/wiki/Microsoft_Visual_Studio

ECMAScript Standards Body: https://www.ecma-international.org/memento/tc39.htm

Erich Gamma, creator of Eclipse and VS Code, member of Gang of Four: https://en.wikipedia.org/wiki/Erich_Gamma

Gang of Four: https://en.wikipedia.org/wiki/Design_Patterns

VS Code: https://code.visualstudio.com/

Anders Hejlsberg: https://en.wikipedia.org/wiki/Anders_Hejlsberg

ECMAScript 4: https://en.wikipedia.org/wiki/ECMAScript#4th_Edition_(abandoned)

Microsoft CodePlex: https://en.wikipedia.org/wiki/CodePlex

DefinitelyTyped: https://github.com/DefinitelyTyped/DefinitelyTyped

Angular 2: https://angular.io/

Deno, a new JavaScript/TypeScript runtime from the creator of Node.js: https://deno.land/

Shanku Niyogi, colleague of Luke who suggested he write the Go VS Code extension: https://twitter.com/shankuniyogi

Handover of VS Code Go from Microsoft to Go: https://code.visualstudio.com/blogs/2020/06/09/go-extension

VS Code Go extension: https://marketplace.visualstudio.com/items?itemName=golang.Go

HCL (HashiCorp Configuration Language): https://github.com/hashicorp/hcl
<!-- END SHOWNOTES -->

<!-- START TRANSCRIPT -->
*This transcript was generated using auto-transcription software and [the source can be edited here](https://github.com/sourcegraph/about/blob/main/podcast/5.md).*

**Beyang Liu:** All right. I'm here with Luke Hoban, co founder of the TypeScript programming language project, and now CTO of Pulumi, an infrastructure-as-code tool that lets you describe your deployment config as, well, code in your favorite programming language. Luke, welcome to the show.

**Luke Hoban:** Thanks. Thanks for having me.

**Beyang:** So , before we dive into, all the cool stuff we're going to talk about, we always like to ask people to tell kind of their backstory as a programmer, starting with how you got into programming in the first place.

**Luke:**  Yeah. So I think, you know, my story probably is similar to, to a number of folks who I started off with programming in the early nineties. as, as, as a kid, I think, you know, for me, my parents, you know, for their work had, and I sort of an early IBM PC clone and the house and, you know, had a DOS on it.

And, you know, it was trying to. Find things to do with, with the computer, just as, as a kid being stuck at home. And I think one of the things, you know, found was, was Q basic. and your Q basic had with it, a few samples sort of projects that you could start. And, some folks who were around in that time will remember Gorilla.BAS And Nibbles.BAS were these two sample projects, which were actually games you could play within Q basic.
And so. I think my, my initial entry was just trying to find a way to play games on this computer that we had in the house. but to get to the game, you had to actually open up the source code file. And so you got introduced to this idea that games and things on the computer were built using software, and that you could modify it.

It was just a file of text that you could change. and so for me, it was, you know, it started as. How can I play games on this computer? And I think it became, Oh, I can make changes to this. I can change the color of this thing. I can change the speed of this, this ball. and so that gave me the idea that that software was a thing you could actually change and modify and kind of started my interest in, in doing various other things with software.

**Beyang:** And, was it kind of a straight path from there to Microsoft or, you know, what were kind of the, the steps in between?

**Luke:** Yeah, someone, I think that was back probably 10 or 11 or something. So, so certainly I certainly took a few steps to get, from there into sort of a professional career. you know, I think, you know, I was interested in, in computers and software kind of all throughout my teenage years and things, and, had a chance to, to do a lot more of that through, through high school and things.

But, yeah, no then went and studied computer science and math, and then got really into sort of the programming languages space in particular and in college and sort of studying programming languages from an academic kind of perspective. but then got the chance, to, to kind of intern at Microsoft.
and just, yeah. Sort of by happenstance. I don't think I'd even expressed particular interest in it, but I ended up any chance to intern in the C# team and got a perspective on what it's like to kind of work on programming languages in the real world, not just in the academic world and really enjoyed it.

Got a chance to work with a lot of people whose, whose names I had known over the years as sort of legends and they were real people and got a chance to work with them on building up C# and .NET in kind of the early days. and I've sort of continued to spend a lot of time in the programming language and developer tool space over the last 15 years or so.

**Beyang:** That's awesome. So, you know, you, you kind of started your career off in developer tools and, I guess that means you've been working in developer tools, for a while now. you know, what are some of the things, you know, as you look at how things are today, you know, what, what was it like back then? You know, when you first were starting out?
I guess it was like early 2000s.

**Luke:** yeah, I think I just joined Microsoft in 2004, so yeah, I think it was interesting, you know, it was, you know, I think different things were happening in different parts of the industry for sure. But, but you know, Microsoft, that was the early days of, of.NET, you know, that that was a broad sort of application platform.

I think it was really .NET and, you know, building on the back of sort of success that Microsoft had had in two areas, one was sort of Visual Basic sort of democratizing access to build a line of business applications, which I think had really started to unlock a kind of a ton of, commercial opportunity across, you know, the entire, you know, not just the sort of raw software industry, but all kinds of companies were now using software to kind of build applications and visual basic.

It sort of made that accessible to a much wider set of people. And, and then I think the other piece was, was sort of calm in the sort of Microsoft days had really enabled what became office and all the rich desktop software that had been built up for kind of around the model of, of all the office applications.
And so .NET was sort of sitting on top of that and trying to sort of get to the next level on that. And I think, you know, had a lot of success in Java was, was kind of very big around the same time and it was taking over kind of the, the enterprise sort of it market. So a lot has changed since then.
The sort of rise of the client side web obviously happened, you know, five. Seven years after that and completely changed how people thought about delivering software. And then of course the cloud has happened over the last five to 10 years and has again really completely transformed how people think about building and delivering software.

**Beyang:**  I really want to dive into kind of your experiences at Microsoft over the years, but, you know, first I want to kinda, you know, get up to kind of present day so that we kind of get the whole scope of, of your career, upfront. So I guess, you know, you, you were at Microsoft for a while.
You eventually landed on the TypeScript project. can you tell us a little bit about, about that?

**Luke:** Yeah. So I think, you know, I, I've been working on .NET For, for many years. I've worked on the C# IDE experience , the C# compiler, I worked on the programming language called F# for a little while and, was looking kind of to try something else. And, and at the time, you know, Microsoft was pivoting quite heavily into kind of, web technologies. It was building the--folks may be familiar with the Chakra JavaScript engine was this engine that, one of the fastest, you know, when, when, V8 came out and some of the other fast JavaScript engines came out and Microsoft also was investing there. And so I kind of went over to the team that was doing JavaScript stuff for Microsoft.

And, you know, it was a few different things. It was the, the runtime project that was some of the tooling that we had. and it was also the JavaScript language itself. Microsoft had folks who were working on the ECMAScript standards body, helping to standardize the language and then evolve it forward, started working with them.
And at the same time, when I, when I kind of first was, was interviewed doing actually with folks on that team, and someone in particular named Steve Lucco, who is sort of the, the architect for that group. One of the things that we talked a lot about was, you know, he had folks coming from the Office team, you know, in Microsoft, sort of saying, Hey, we're, we're moving, you know, hundreds of developers a day over from doing desktop C++ software to client-side JavaScript to build these rich new, you know, web-based, Office products. And so the online versions of Word and Excel and everything, and he was saying, you know, they're, they're kind of falling off a cliff in terms of the, the toolchain and the experience they get for, for building these things.
They're, they're building as complicated of software, but without the IDE tooling, without the type checking, without any of the, the things to fall back on, so they were sort of demanding that there was, you know, what are you going to do about this? You know, you guys, you guys own the experience around this, this language, this tool says that this, this toolchain, you know, where, what can we do to attempt to make this something that, you know, thousands of developers can productively work in Office?
I think we saw that the same thing was happening in other parts, this industry that were kind of the leading edge of this. Google had, you know, a number of projects that they were using internally and some of them that it started to, to make it outside of Google that were managing the same kind of complexity that they were seeing--
Well, Dart was a little bit later actually but at the time. It was actually something called a Closure Compiler, which is still used

**Beyang:** Oh, right. Yeah.

**Luke:** Google. I'm not, not nearly as, as sort of a, broad of a tool, but we'll actually, probably I'd say Closure Compiler was our biggest inspiration for, for really, because it would show no, it was initially it was sort of a, just a minification tool, a tool to make the payload smaller that you send over the wire, but it started growing all these ways of adding comments to your JavaScript code, to annotate things that were true about it.

And that, that, that you, they sort of ended up reinventing a type system inside those comments that you could apply and get them checked in those types system comments would, would inform how to do that minification process. And so were kind of reverse engineering, building up a type system for JavaScript inside these comments.

And we just thought, Hey, you know, Why not go and put that type system in, in the real language itself. And what could we do if we, if we did that and then got all the tools, benefits that we, you know, because we build Visual Studio and all of these IDEs, we kind of knew what it looks like to get all of those tooling benefits from having a type system.
So, so that was sort of the, the genesis of, of, working on. TypeScript and yeah, we, we started off as just a small project that Steve and I working on and then, pulled a few more folks in and, you know, it ended up growing into a pretty big thing. Now it's, it's quite heavily used obviously across the industry.

**Beyang:** What was kind of your, did you have. You said you, you were working on a couple of web based projects. Was there any like project in particular that you were initially targeting as like, Hey, you know, we really want these people to be building their, their, applications in, in TypeScript.

**Luke:** Yeah, I think, you know, we were initially pretty focused on internal teams and I think when we started working on the project, we weren't sure it was ever going to be something which would exist outside of, outside of Microsoft. It was another possibility that it would be just a tool for, for some internal use.

And I think, you know, Office was obviously the one that, that was the big motivation. and you know, they were the people that we kind of talked to the most, but, you know, as with most of these things, big, huge teams with Office that are already trying to solve their problems in practice today, aren't normally the best candidates to be sort of your first user of something new.

And so, and so we talked to folks in various parts of the Office team quite a bit, but, but I think they, you know, they, they, they weren't ready to go and dive off a cliff, do some totally new thing in the early days. There was actually a team though, that that was closer to us. It was actually in the same organization as us.
That was, someone named Erich Gamma had joined Microsoft, one of the authors of the Gang of Four, you know,

**Beyang:** Yeah. Eclipse and VS Code 

**Luke:** Yup. And so Eric had joined Microsoft right around the same time and was very interested in this same space and he was very interested in building a, kind of a web based, IDE. and so, When he started doing that, you know, he, he actually knew, you know, he knew us, he talked to us a lot and he was like, Oh, I should use this early TypeScript thing.

And so from the very, very early days, you know, he and his team were were a customer  effectively, of this very early stage version of TypeScript. I'd say time, he started adopting it. You know, it worked honestly, so a lot of, a lot of credits to him for sticking with it and not abandoning it in the early days, but it did mean, I think that was really critical to sort of get that feedback loop from a real project that was kind of betting on TypeScript from, from very, very early on. And of course Erich and his team have gone on to build the software they were building at that time was, was really the, the core pieces of what ultimately became VS Code, which didn't ship publicly for another three or four years, but was used in a bunch of things inside Microsoft in between that.

**Beyang:** I mean, that almost sounds like a match made in heaven because you know, the, the language support for TypeScript in VS Code is fantastic. And you know, now it's, written in TypeScript and, that sort of feedback loop, it sounds like, th the conjunction of those two tools, you know, I've certainly got a lot of value from both of them.
And, it's great that you were able to like, kind of feed off each other from the very beginning.

**Luke:** Yeah. And I think it's particularly kind of fun to have an IDE being built in the language it's being written in, you know, in a sense. And I think that folks, you know, Erich and the folks on his team, I think really enjoyed that they were able to, you know, sort of that dog fooding loop, right. They were able to build the tools that helped them be productive. And so they very early on have this experience of kind of that super quick feedback loop. And it's something that, you know, for folks who do build developer tools, I think it's one of the things a lot of people love about building developer tools is the idea that you can be your own customer in a sense, and you can really get that super quick feedback loop.

You don't have to go out and interview your customers. You can feel it every day. And so I think they initially actually focused pretty heavily on you know, that TypeScript experience, the Markdown experience, because that was the other thing they were doing was writing a lot of docs and things like that in Markdown but, but those experiences and the IDE that they could use heavily and sort of get that day to day feel of what it was like. And TypeScript was a big part of that. And so they invested heavily in kind of the TypeScript tooling which meant that we were able to show off refactoring support, right, and you know, really rich features much earlier than we might have otherwise been able to kind of show those to people.

**Beyang:**  Who, who was the founding team of, of TypeScript and, you know, when did various kind of key people come onboard the project.

**Luke:** Yeah, I think, you know, we, we, I think when we started, Steve Lucco and I kind of were, you know, started the project and started working on some things there. I think we had a handful of other folks who were involved, you know, early on doing some, some engineering work, you know, related to the project.

You know, some of it was just people who were part of some of this neighboring projects, like, like the Chakra engine and things like that who kind of, were involved in some of the design discussions and things like that. And then, Anders Hejlsberg obviously, who, you know, continues to sort of run the project now.

He, you know, he kind of joined us just a few months actually, after we, we kind of started working on things. He was, you know, he had been doing C# for, for many, many years. And, and I think, you know, continues to have a hand in, in C# and in .NET as well. but I think he had seen the same pattern of industry interest in, in the JavaScript space, and felt like, you know, he, he could, you know, I think what many of us did, I think felt like the place where he could sort of bring his, languages hat and, and sort of have a big impact was in doing something related to how we move forward the state of the art for kind of web and frontend development. So I think and Anders is, I mean, Anders is one of the favorite people I've ever had the chance to work with in my life.

And I've been lucky to have the chance to work with him on several projects. And, you know, he just has a, an intuition about program language design and developer tool experience that is, is really just incredible. And, you know, it's one of those people who, whenever, whenever he and I disagree, I know I'm wrong and I,know, I just have to figure out why it is I'm wrong.
And I have to wait until my mind can catch up, but he just has a really great point of view and design sense and then aesthetic around, around developer experiences. So, you know, obviously had a huge part of shaping kind of what TypeScript ended up being was, was having Anders be heavily involved from pretty early on.

**Beyang:** What, what was the language like back in those early days? You know, if a TypeScript programmer were to go back in time and look at the language as it was then would they kind of recognize it or has it changed substantially and drastically?

**Luke:** I think they would recognize it. I mean, there's, one of the key things, which is was the principle of kind of TypeScript. The codename for the project was Strada back at the time. And so I might find myself saying that, but the thing that was,

**Beyang:** Where does that name come from?

**Luke:** I think we had a set of code names that were all, towns in, In, in Italy and France, as was one of the other projects. So these were all towns in that area of the world. I think there was several other projects. I think the Chakra engine was, was called Eze back in those days. But, but yeah, the one thing that was sort of, a core principle in a sense, even back in the very earliest days was this idea that, that TypeScript would be a layer over JavaScript.
And so it would be sort of an incremental set of additions, in terms of the syntax of the language over JavaScript. It wouldn't be a whole different thing. So for instance, you mentioned Dart, which was another project that was nominally in the same space of trying to solve some of the same problems, but didn't start with that assumption, right?

It started with the assumption that we should have a new language, a new syntax that wasn't JavaScript, and, and. And I'd say even, you know, even look at something like Coffescript, which was another motivation back in that time and had grew up, you know, I think that the huge adoption we'd seen of Coffescript in the, in the timeframe of when we were starting the project sort of was a key thing that gave us the sense that, Oh, it is possible to build a tool that compiles down to JavaScript and it does get broad adoption. And that seeing that that existed was important, I think, to motivate us. But, but yeah, so I think the fact that it was JavaScript syntax with some additional syntax on top really defines what, what TypeScript feels like in a sense, right?

I think there's not many languages that, that, that is true for it. And so I think that was true back then. It's still true today. The language has stayed true to, I think its roots of being a pretty thin layer on top of, on top of JavaScript. And so I think that stays true. I think there's some places, you know, there was some syntax that was different, you know, the, the way that, types are, currently in, in TypeScript are, you know, variable name, colon, type.
Think back in the earliest days we had type name, space, variable name, you know, instead of var X equals something, it would be int x equals or number x equals. 

And actually one of the motivations for that was that, you know, C# had "var" as, you know, the kind of "any" type, right? It had recently introduced, the ability to basically have, an "any" type in the type system and var was this keyword already in JavaScript. And so it was like, Oh, well, you know, that just makes it so that if you don't specify the type then, you know "var" is this specifier, that it can have any typing. And so it kind of, felt very natural from a C# perspective, but there's a whole bunch of reasons just from a parsing perspective that that gets you into trouble.

And this is much harder to deal with than, uh, postfix things. So, we, we ended up gravitating with it. I think the other piece was actually, ECMAScript 4 was this attempt to actually add types to the JavaScript language in the standards body that had been done a few years before this and it had sort of, it had been a long effort in the standards body have been motivated by ActionScript and then driven by some of the folks who were involved in ActionScript and it had ended up kind of changing JavaScript too much. And so it got very heavy and diverged a lot from what JavaScript really was on the web. And that happened around the same time that, that the web, that JavaScript itself was really taking off in practice.

And so it sort of became, it was the wrong timing for that project. And so it kind of ended up getting canceled and they went back and sort of abandoned ECMAScript 4 and just made smaller steps forward with, with with, with the standard JavaScript itself. And I think ECMAScript 4 had used this same syntax of this postfix colon kind of thing.

And so I think that was probably another thing we attached to is that there had been precedent on how to add types into JavaScript with that kind of syntax.

**Beyang:** Got it. I mean, the way you explained the decision process behind that decision is, is really fascinating, but I imagine there must have been a lot of other kind of things like that, about the syntax and ergonomics of the language. How do you, how do you settle debates, about things like that? You know, like programmers, we can't even agree on tabs versus spaces. When, when you're creating a language, how, how do you make those choices?

**Luke:** Yeah, I think, you know, it was one of those things where it's, you know, it's definitely an art, not a science. and so you can, you can, you know, bring data into the discussion about, Hey, what do other languages, do, you know how, how complicated is it from a parsing perspective, a whole bunch of data you can bring into those discussions.

But at the end of the day, it is just, an aesthetic choice. and it is part of just the really thinking about, you know, kind of how it's going to feel, how it's going to, you know, interact with, with IDE tooling, how it's going to, you know, even what it's going to remind people off in terms of other languages they might have you've worked with and how that's going to set up their mental pathways to sort of use things the correct way versus the incorrect way by default. And so this is something that I think, you know, I kind of mentioned Anders is really, has just a great aesthetic around this kind of thing. And I think really helped kind of having him there to kind of break the ties and make the decisions and kind of be the, the person who could just have a great intuition about what was the right thing to do from a, from a syntax and then experience perspective around the language.

**Beyang:** So, you know, TypeScript, I believe the project was begun in 2012, right?

**Luke:** Yeah, that sounds right. 2011, but yeah, that sounds about right.

**Beyang:** Okay, got it. Or maybe it, maybe it was like first, like, publicly announced in 2012. Cause I remember it was very shortly after we started Sourcegraph. I think that I first saw like the, the first public announcement that I saw about TypeScript and, I kind of want to talk about how like Microsoft has changed since then.

'Cause certainly from the outside looking in, it seems like a very different  company now. It seems like, you know, Microsoft, as an organization has embraced open source and they have projects like TypeScript and VS Code now that have been wildly successful. But if we go back in time to, you know, 2012, 2013, I feel like the brand perception among developers of Microsoft was very different. I think that might also have been reflected in the culture a little bit. I think TypeScript might've been the first major open source project from Microsoft in a while? So can you talk about, kind of getting an open source project like this off the ground in, inside Microsoft of, you know, 2011, 2012.

**Luke:** Yeah. So I think, I mean, I can certainly speak to kind of what it was like back then. you know, both kind of before that, and in the few years after that, obviously, you know, I, I left Microsoft in 2017. So, in terms of, I think a lot of, a lot of the changes there have continued to maybe even accelerate over the time since, since I left Microsoft.

But certainly, you know, I think,  open source, wasn't, you know, a huge part of Microsoft's DNA obviously, you know, back in the early 2010s, right. And you know, there were some famous sort of anti open source kind of rhetoric, that, that had come out of Microsoft in the not many years before that. One thing I think that is interesting though, is, Microsoft has, you know, had back at that time and, you know, even when I first joined it and still has a, a quite large, developer division, which is a whole division of the company, which is, focused on building developer tools. And, and that, that division had existed for some time. And, and I think gives, you know, unlike a lot of other companies, I think Microsoft has a strong identity around, you know, building, uh, building developer tools. And in fact has a, has a whole business around this, right? I mean, it was sort of famously one of Microsoft's, you know, many billion dollar businesses was actually just its developer tools business.

And so one of the biggest, you know, developer tools, businesses, even, even sort of strictly independent of anything else that Microsoft did, it had, it had a big business building and delivering developer tools. and so I think that gave it a, a center of strength around, you know, building things for developers that was maybe even slightly independent of, you know, what mattered for Windows or Windows Server or Office or anything like that.

And so, and so I think some of that focus on open source, I think really did come from that developer division. And the developer, you know, the folks building tools for developers, seeing what was happening across the rest of the industry and just how much the developer tools landscape was being reshaped by open source projects, whether it was open source tools, whether it was open source frameworks and libraries, lots of different things that were, were reshaping, how developers thought about what they built in. And that, that was not just something that was in some, you know, very specific Linux-based world. It was, it was something that was, was happening across the industry, even for folks building software on Windows or building software for the web.

And so I think there was that strong sense that open source was this important force for developers that was, was present, through that time period. Yeah, no, I think in terms of actual, In actual open source projects, you know, there had been some relatively small open source projects before TypeScript, obviously, but, but I'd say, I'd say TypeScript was one of the early, open source projects that, that Microsoft delivered.

And one interesting thing, this may be of historical interest. When we launched TypeScript, we did have, you know, a lot of debate internally about making it open source in some, I think it was. You know, possibly just because people at the time didn't necessarily think TypeScript was going to be a particularly big thing right? You know, it was just sort of an interesting, an interesting project that had seen some usage internally.

And we just thought it was sort of a nice thing to get out there. But, you know, there, there was a lot of debate about making it open source and I think ultimately, you know, got approval to say, Hey, we're gonna, we're going to go and release this as open source, but the one caveat on that was, But we need to put it on CodePlex, not on GitHub and CodePlex was the site that Microsoft had that was, was an open source code sharing site. Very similar to GitHub. Honestly back in those days, I think it wasn't even a hundred percent clear. I'd say it was probably 80% clear, but not a hundred percent clear that GitHub was going to dominate this space. And so, you know, this was part of, Hey, we, if we're going to do these first party kind of open source projects, let's put them on CodePlex.

Let's, let's create the home, let's dogfood, our own open source code hosting tools as well. We put it there. I think about a, about a year, maybe a year and a half later, we did end up moving it over to GitHub. I think, I think it was, it became more and more clear. That GitHub was where the community and ecosystems were.

And so we did move it to GitHub. And obviously it's lived there for many, many years now since then, and has built up a huge, huge community, of an ecosystem around that GitHub project. But, but yeah, it was interesting that even in the early days of embracing open source, it was almost like, Hey, if we're going to embracing open source, let's go and do it, you know, in our own open source community and build up our own center of excellence and strength around CodePlex.

And I think that that might've been an alternate history where CodePlex became the, the dominant code hosting platform.

**Beyang:** Yeah. You mentioned that, you know, in the beginning of the project, you know, it wasn't clear whether TypeScript was gonna take off, you know, these days it's obviously, you know, I think it's almost ubiquitous. It's everywhere you look. Was there a single inflection point or maybe a collection of milestones that you remember hitting that were kind of, Like step, like step, step, step functions, upward toward increasing adoption ?

**Luke:** Yeah, there's, there's, there's two things that I kind of, always think back to that I think were, were really, Really changed the way that I thought about what TypeScript was going to be, and I think had a big impact on its growth in the industry. I think the first happened, you know, I think the day after we, we actually launched TypeScript publicly and I remember when we launched it, you know, I obviously thought I was obviously, that was great.

I spent a year and a half working on it before we launched it and, and was, was very passionate about it and had been singing its praises everywhere I could go. But, but I. I thought it was going to be valuable for only for big teams. It's only for the kind of teams like the Office team that we had originally kind of focused on.

And the reason I thought it was mostly gonna be valuable for them was that, I saw this sort of one, what I felt like was going to be a, the kind of barrier to entry in a sense, which was, you know, to, to work with TypeScript, you, you know, anyone working with TypeScript would have been working with lots of other JavaScript libraries.

They would've been working with jQuery or, you know, whatever it was else at the time that was popular. And. You know, they would have to go in and describe the API boundary with that library. So they would have to sit there and write down what all the types are that the interface to that JavaScript library they're using to get the benefits of TypeScript.
I assumed that was something that each individual project, you know, each team that adopted TypeScript was going to have to go and do that work for all the libraries they wanted to work with. And that was just going to mean there was going to be some upfront costs to adopting TypeScript, which was you have to go and describe all this stuff.

I think the thing that popped up the day after we shipped was this DefinitelyTyped project that was started by someone in the, in the community. And, just on GitHub, he started collecting both the descriptions of some of the APIs that we had made available as open source in the original release.
Like with some of our examples, we'd shipped a simple version of jQuery type descriptions. And, and of some of the core JavaScript libraries and he collected those, he added a few more, he found a couple people on the internet who had written blog posts or something, and  had written up some, some things that pulled them into this library and he basically started curating a home for these, these type descriptions.

And I think that ended up being this really critical thing that A, was it sort of, showed me just that, that the power that these open source communities can have to just aggregate value together, organically evolve, organically evolve these assets like this didn't have to be perfect. And so people could just incrementally improve them incrementally add them, incrementally share them.

And that became value that everyone then got. And so it became the case that most folks coming to TypeScript actually could get started very quickly because the library they were working with did have a type description. And if they hit a limit with it, they could go and submit a PR back into that DefinitelyTyped project.

And so I think that that open source ecosystems and the,  the power, they can have to unblock some of these, kind of difficult scale challenges was, was one of my early kind of lessons. And I think, I think had that project and not popped up, it could have, you know, TypeScript may not have ever fully taken off and it could have taken several more years for it to, to have any, any big impact.
But I think now in some sense, the fact that there is that giant library of type descriptions for TypeScript is this even independent of TypeScript itself, that is this amazing asset the industry has. This sort of API surface area of all these libraries is now formally defined. and so I think that's a, that's a great thing.

The, the second inflection point I think about was actually, it was actually after I stopped working on the project, then, you know, I still, I still talked a lot with the folks who were kind of leading the project at the time, but it was actually when, when the Angular, Angular 2 decided to adopt TypeScript as this sort of default  language for Angular, for, for their second kind of version of Angular and, you know, I think this was a case where TypeScript had been used by a lot of big companies and things like that, but it's just the first example where a big kind of ecosystem adopted it en masse, and, and kind of made it the default and created a distribution channel for it, where everyone who wanted to go and learn and use Angular 2 was getting introduced to TypeScript on that journey, without having to independently make the decision to, to kind of go and look at TypeScript.

And I think that really just completely changed the arc of the adoption curve. you know, put it in front of so many more people. It meant that a whole generation of kind of people coming through the. you know, the, the JavaScript front end development experience got introduced to it on that, on that journey, and meant that as they spread out into other parts in industry, there was just so much more awareness of the value that that TypeScript could bring.
and so I think, I think that was, you know, that was another really significant inflection point for the project. And I think then, you know, it kind of went on to get great experiences in React and in other frameworks. And so now these days, I think, you know, most frameworks have, you know, try to make sure they have a good experience for it, for TypeScript out of the gate.

And now you're seeing things like, like Deno and things like that, which are built around TypeScript from the get go. And so, so I think, but I think that first example with, with Angular I think was really, really key to --that was also it wasn't just an accident in the sense that I think that was something that the folks on the TypeScript team worked closely with some of the folks in the Angular project to make sure that it could work well with that and to make sure they did have support. And I think they did actually at Microsoft and Google did a joint, joint announcement of that, which was, at that point in time, you know, Microsoft and Google were as much enemies as anyone could be in the popular perception of things.
But the fact that they were collaborating on open source developer tools I think was, was, was great.

**Beyang:** Yeah, that's awesome. I think over the course of any, project, there's kind of tradeoffs, you have to make, you have to balance, kind of, decisions of like vision and personal preference from the creators with, you know, all the different feature requests that you get from the community, and your users. As you think back over the course of, the evolution of TypeScript, were there any, like features that you ended up rejecting that you thought, you know, maybe that should have gotten in or, you know, any kind of contentious, debates, about things that did or didn't make it into the language?

**Luke:** There was a couple of sort of particularly interesting contentious debates before TypeScript shipped--you know, I think, you know, one of the interesting things is TypeScript is sort of set up to be particularly amenable to some of these concerns, but also to have sort of a built in way of addressing them. And that's because as I mentioned it, you know, it is just a thin layer over JavaScript in a sense.

So because of that, you know, A, it sort of, people can want it to do more, in a sense. They can say, Oh, there's all these problems with JavaScript. I want TypeScript to fix all those problems. And, and so that can lead you to want to go and do more stuff and diverge more from JavaScript. But I think in a sense, TypeScript also had the solution to that problem built in, which was, Hey, no, we aren't going to be, we are going to be a superset of the JavaScript language. So we're not going to go and change things about JavaScript itself. We're going to extend JavaScript. And even within that, we're only going to extend it effectively to first order.

We're only going to extend it by adding a type system. We're not going to extend it by adding kind of random new expression-level syntax to the language. And into that idea that it was a very thin layer helped to sort of break a lot of the ties on this. But there was a couple of things I remember, you know, early on, that were actually contentious.

One of the interesting things when you add types to a language is that, it turns out you really end up wanting to also add something like classes at the same time. And that's because when you add types, but you don't, if you don't have classes, you kind of have to say everything twice. You have to describe the interface for the, for the class-like thing in one place.

And then you have to describe the constructor for the class-like thing in another place and the methods and everything. And so it's sort of like you have to describe the interface and the implementation independently. And so one of the things people love with classes is they give you kind of an easy way to describe both the interface and the implementation together in a very succinct way. And, and so you can use TypeScript, of course ,without classes, but, you know, classes become, they feel even more natural when you're both describing types and describing implementation. And so at the same time that we were thinking about TypeScript and kept getting pressure, you know, to, to kind of add classes into, into TypeScript because of this, classes were also being discussed in the ECMAScript standards body. And so the JavaScript itself was, was likely to evolve a class-like notion, you know, I think there was a lot of, you know, I was, I was heavily involved in the ECMAScript standards body at the time. I was driving a lot of kind of design proposals and things there.

And I think we, we had a lot of back and forth on what that class syntax would look like, both in the TypeScript world and in the JavaScript world and, I think , ended up kind of, I think a big, a big decision point, not long before we could publicly release TypeScript was to bet on the class syntax and the class design that was being used in the standards body over going with the thing we thought was probably better for TypeScript.

And I think that bet was not a sure thing because that ECMAScript standard hadn't been, you know, hadn't been finalized yet, hadn't been published, and was not really adopted by any browsers in the industry yet. And the previous version of the standard had, you know, kind of crashed and burned. And so, you know, it was not clear that it would ever get fully adopted, but it was sort of a bet on aligning with standards and aligning with continuing to be a layer on top of JavaScript versus trying to invent, kind of, our own things, and ended up more or less paying off.  I think that classes obviously did get adopted in JavaScript. They are now fairly heavily used within JavaScript. So I think that decision was probably also really key to making sure that TypeScript really did stay a thin layer and didn't start to diverge more and more fundamentally from, from JavaScript itself.

**Beyang:** Yeah. What is it like to be part of a standards body? Like, you know, the ECMAScript standards body. Like I imagine, like standards are extremely important. it's important, you know, all voices are heard, but at the same time, I imagine it's quite difficult to find solutions that, make everyone happy.

**Luke:** Yeah, no, I think it's, you know, it's particularly interesting. The thing about standards is they just have a lot of different parties who are kind of involved in, you know , for the ECMAScript standard, I mean, it was really, as you might expect, it was sort of all the big, all the big players in the web and browser space, you know, Mozilla was, was very heavily involved there. Google was very heavily involved there. Apple was involved there, Microsoft was involved there. but then a lot of other, you know, folks who just had various interests in, in the evolution of that language. And, and so there were a lot of different perspectives. One of the good things is that, you know, that JavaScript, JavaScript as a programming language, doesn't have deep corporate interests attached to it.

You know, there's not like there's not ways to, you know, fundamentally twist the JavaScript programming language into being better for Google or better for Microsoft or something. And so it did mean that, you know, I think at least for that particular project, versus, you know, in some of the web standards work, for example, you know, there's, there's a little bit more, Some of the politics is, is more fundamental, I think, to the evolution of some of the web standards.

But, but in, in the JavaScript ecosystem, I think that was a bit less so and so it did mean there was, it was more of a, just a, honestly kind of a fun, collaborative, environment for evolving this, this language, which is very critical for so many developers. And it had become such a key part of the web.

But a venue where smart folks from all the big, you know, software companies at the time were, were participating in that and helping to drive that forward, and, and bringing the perspectives they got from their various user bases to bear on that. So I think it was a, it was a great and it was, honestly, as much of a, sort of deep technical language design, you know, community as, as the C#  or TypeScript teams that I've worked on were, but just with a bit more of a diverse kind of perspective that was brought from all these different organizations. Yeah there was definitely some, some, you know, things move slowly in standards world, and you know, a bunch of these standards have been worked on for many, many years. And even from the time they're worked on to when they, you know, have broad adoption within the industry can be, you know, Could be on the order of 10 years. There's things I worked on in, in the ECMAScript standards body, you know, back in 2011 or so that I think are just now becoming, you know, widely used things in the industry.

But, but no, the impact you can have obviously working on things in that standards body, probably some of the things I've done in my career that have had the biggest impact have been things that I did to, to move the JavaScript language forward in small ways, because they just, impact, so many, so many people.

 **Beyang:** So in addition to .NET and TypeScript, you've made a substantial contribution to another programming language community. And I want to ask you about that. So, you know, you were the author, I believe, of the VS Code Go extension. How-- what was the backstory behind that?

**Luke:** Yeah. The Go extension just last week, I think, was transitioned from being in the Microsoft , you know being managed by Microsoft over to the Go team at Google. So, so it's actually now made, you know, it was, it was a project that was my project. And then I kind of handed over to be managed by some folks at Microsoft when I, when I left Microsoft.

And now it's just kind of moving over into the Go team. So I wrote a little kind of, yeah, a little bit of backstory on that. as part of that handover, but no, I think it was a, you know, I had been involved, I mentioned earlier kind of, we we'd been working on the TypeScript side with, with Erich Gamma and his team from the very early days.

And, and so I, you know, even after I left the TypeScript project, I did a lot of work with, with Erich and his team, even before they kind of decided to build VS Code and you know then, they launched VS Code. And then I think it was about nine months or a year later, they were planning on doing a, sort of a big announcement of, open sourcing VS Code.

When, when VS Code was originally launched, actually wasn't open source, but about nine months later or a year later or something, they did open source it. And as part of that launch announcing that it was open source, they also wanted to highlight the extensibility model and sort of open up the API for folks to build extensions for VS Code.

And I was providing kind of feedback to, to, to their team on the API and some of the things related to extensibility model. And, we were in a, in a conversation we were having, just, you know, about how we would position the extensibility model when we, when we launched this. One of the things we really wanted to do was make sure that,  VS Code was perceived as not just being a Microsoft ecosystem .NET IDE, that we really wanted to make it clear that it was meant to be a developer tool for any language in any kind of tool that any, any developer on, on any platform. That was another key thing about VS Coe obviously, was it, it wasn't Windows-only, which was, I guess surprising at that time for Microsoft. And, and so one of the way, you know, I think one of my colleagues at the time, Shanku Niyogi, sort of made what I, what I, what I heard as a joke.

He since told me it wasn't a joke, but he's like, well, add support for, for Go and Go at the time was, was a fairly new language. It had a ton of buzz, was growing really quickly. It was kind of perceived as being, sort of an anti C# and Java in a sense, right. It was the new wave of what, what, you know, server languages would, would look like.

And, and I think, you know, we--he kind of threw that out there as like, Hey, this would be a way of sort of showing the, the, the other extreme, right. A language that's built by Google, a language that's, you know, sort of perceived as being competitive in a sense with the C# and Java kind of world, you know, having support with that would really show that this is, this is not your traditional Microsoft developer tool.

And, and so, yeah, so that's kind of stuck in the back of my head. And then when I was, when I was playing around giving feedback to, to the VS Code team, I thought, Hey, well, why don't I just try to do, try to build a tool, for both tooling, for Go as the, as the example to use, to give them feedback.
And so I started, just playing around with that, kind of the next few nights and things, and had a simple demo of something and showed it to Erich. And, you know, I think he was kind of kind of incredulous that it could even work because the way these things work at the time at that time of, you know, you obviously know, you built that kind of, IDEs and that sort of thing as well.

But you know, it worked by shelling out to, a binary. Every time you hovered over something in the IDE, we would shell out to a binary, run that, get back the result and then present that in the tooltip. And so, you know, you're potentially doing this tens of times a second right as you're hovering over things.
And he, you know, Erich was like, Oh, there's no way that can be performant, right? We always do this stuff in memory. We always, you know, we have all these techniques that are fancy around how we kind of manage, you know, this kind of IDE tooling, but it turned out that Go binaries are really fast. You know, it's one of the nice things about building flat native binaries is, is they, they, they load fast and they run. They can, they don't have a lot of upfront, spin up time. And so, yeah, so we, so we, you know, had this tool, it actually works surprisingly well. I think, you know, it used a lot of the techniques that some of the other tools in the ecosystem at the time had been pioneering, like the Vim Go extension.

That was probably the most popular tool. Still is one of the most popular tools for working with Go, had shown this pattern of using all of these little, little tools that were available in the Go ecosystem, and kind of plugging them all together. And. Yeah. So we did that. We, we initially, at, at that launch of the open sourcing of VS Code and, and, the release of the extensibility model, we showed off this, you know, just as an example of what you could do with the extensibility model, we showed off this, Go support Erich on stage at the conference where you don't see that, kind of demoed that for a couple of minutes. And yeah, I think even then, we didn't really think it was necessarily going to be something that a lot of people used.

It was more of a marketing exercise to go show off what was possible. but it, it turned out there was, there was a lot of desire for richer kind of, richer tooling in the, in the Go space as Go was taking off. And a lot of people started picking it up and I started spending more time kind of supporting an open source project.

And, yeah, it ended up kind of taking off. And I think these days, it's now, you know, one of the most used tools out there for, for Go development, which is, which is kind of cool.

**Beyang:** How much Go had you written before writing this plugin?

**Luke:** Like no, no actual Go, like no production, uh, Go, I know, because I am just sort of a student of programming languages in a sense. I, you know, whenever any interesting new program, which comes out, I play around with it, I'd say from an academic kind of perspective. And so I, I, I understood that the language sort of from a, from a, what it is perspective, but I had never been a user of Go at all.

And so that, that did. I think that did mean, I, I, I didn't understand, you know, that what was important for the tool viscerally in the same way that I think I came to understand it was important for the tool over the coming years, when, when I started working on it. but it is always one of the interesting things as you, as you build tools, I mentioned that sort of quick feedback loop.

If you are somebody who, you know, building a tool for yourself, I think you can get that. But I'd say I didn't have that experience at the time. And in fact, it was many years before, you know, now these days I write a lot of Go code and I use that Go extension every day. And so now you're a user of it and get through it sort of reap the rewards of that.

But, but at the time, no, it was, it was, I was definitely building for someone else in a sense.

**Beyang:** Yeah, that's interesting. You know, you're now the, well, you're the second person I know of who, who wrote an editor plugin for a language that they didn't have that much experience with. The other person is, my teammate, Felix Becker, who wrote the, the, I think it was one of the first PHP language servers. Had not written much PHP before.

And I wonder if there's something to that experience of, cause like, if you're already proficient in a language, we've kind of gotten used to the like tooling ecosystem in that language and you don't, maybe that blinds you to a certain extent to seeing how it might be improved. Whereas like, if you're going, if you're new to it, you're like, Oh, you know, I'm used to using these tools.
How can I adapt that experience to this new, ecosystem?

**Luke:** Yeah, I think there is an aspect of that. And I think, you know, it can, in a sense, go both ways, but, I think it was a sense back in those days, for example, that, there was a strong sense that Go developers didn't want IDE tools, you know, the Go developer wanted to be in Vim or Sublime and, you know, wanted to have this very simple experience. Go gets--sort of part of Go's aesthetic in a sense has to be this, this fairly simple, you know, language.

And I think, you know, you Go talk to the folks who are creators and leads of the Go language. And I think, you know, you know, one piece that's kind of related to actually, you know, I think it was, I think it's Rob Pike. I forget maybe it's I think it was Rob Pike who had a comment. It's basically, you know, somebody asked about debugging support in Go, and he's like, you know, the only debugger you ever need is printf debugging. Uh, and, and I think there was that sense from the Go project itself that--and from a lot of the early users of Go--that that was part of the ethos of the language, was to not have this kind of heavyweight, Java and C# style IDE experiences. And so I think, you know, it did take a little bit of that, an outsider coming in from those perspectives, Erich Gamma, coming from the Eclipse kind of world and the VS Code world.

You know, me coming from the C# and .NET / TypeScript world. I think having that perspective that, Hey, maybe, maybe we don't want to go all the way there, we don't want to have, you know, this feel like, like, you know, Java and Eclipse, but there might be a step in between just raw Vim and full Visual Studio. And I think VS Code itself is sort of designed around that idea that there might be this point in between.

There might be this thing that's kind of halfway between a text editor that can feel a lot more lightweight than an IDE, but can feel a lot richer than a text editor. And I think the Go extension and sort of bringing some of the, the key tooling capabilities that VS Code was able to light up in a natural way around hover tips and error feedback and, and some of those sorts of things.

I think it did come in some sense, from a bit of that mindset that, Hey, you know, IDE tooling, some of this stuff can actually be valuable, even for languages like Go.

**Beyang:** Yeah, that makes sense. So, you know, I feel like I could spend an entire day talking with you about TypeScript and, you know, your, your work on, in the Go ecosystem and, your time at Microsoft, but I want to get to, what you're doing now, which is, as interesting, if not more. You're CTO of a company called Pulumi, that, creates this infrastructure as code tool that we use at Sourcegraph,  and I can personally vouch for it. It's fantastic. kind of the idea is that you can write your deployment config, as kind of like just code in your favorite programming language. so, you know, tell us about the journey from Microsoft to, that position.

**Luke:** Yeah. So I think, you know, I left Microsoft back, I think 2017 and I ended up going to, to AWS actually, I'm working on, on  EC2 doing a bunch of so raw cloud compute stuff there. Had a great time there. I mean AWS is just an absolutely incredible kind of business and EC2 in particular is just, you know, the size of that business, the rate of growth is incredible and really, really fun and some great folks there.
I think. You know, I obviously had sort of had an understanding of what was going on with the cloud, just from being at Microsoft and Azure and things like that. but, but certainly being at AWS gives you just a whole nother level of perspective on kind of what is happening around the cloud and the breadth of, of adoption, and how that was changing, how everyone was, was building and delivering software.

And one of the things that, you know, I had been thinking about it back of my head for a long time was just, you know, Hey, you know, I kind of come from this programming languages perspective, this dev tools perspective, like that's, that's my hammer. You know, that's, that's my thing I bring to the table is like, how, you know, this is a thing I can use to kind of help solve these problems, but thinking for a while about.
No in this cloud space, incredible building blocks that these cloud providers have made available. You know, AWS has hundreds and hundreds of these services, which take away operational complexity, you know, really simplify what you can build and how quickly you can bring that to market. and the problem really was just those building blocks are still really hard to kind of put together.

You know, to, to actually go and build an application out of those building blocks requires an incredible level of expertise and proficiency in infrastructure development,  sort of instructor operations. And so it sort of, it felt like there should be a kind of programming languages and developer tools and software engineering, way of thinking about that, that you know, those in those disciplines, we have built up great tools for taking great raw building blocks, whether they're operating system primitives or standards based technologies in the web browser.

And democratizing access to them by adding layers of abstraction and layers of software engineering capabilities on top of them and layers of programming languages and IDEs and things. And so I think the, the genesis of kind of Pulumi was, you know, me and Joe Duffy, who is founder and CEO, like really believing that, there was an opportunity to significantly change how we think about applying software engineering to cloud infrastructure and to really harnessing all the value that's out there from the cloud providers.

And I think we've been on that journey now for about three years, kind of launched the Pulumi open source project about two years ago. And I've really seen that, that takeoff, you know, really significantly over the last two years. And I think there, there has been, a lot of desire out there in the industry to, to really bring to bear what software engineering and all these things we've talked about over the last, you know, a little while in this conversation, bring a lot of that same thinking into the cloud infrastructure space and make it accessible to a broader collection of users.

**Beyang:** So how would you describe Pulumi to a, you know, someone who has never used it before? You know, there are there a number of other tools that are kind of in the infrastructure as code space, how's Pulumi different from those and why should people use it?

**Luke:** Yeah. So I think of, you know, Pulumi is really one way I like to talk about is sort of thinking about not infrastructure as code infrastructure, but infrastructure as software, so really trying to bring all those software engineering capabilities that we know about, whether it's, you know, the ability to create reusable abstractions, or to publish reusable packages or use IDE tooling, or, you know, debug or test or all these things that we know that sort of support rich robust, you know, scaling up all of the, the kind of applications you can build, bringing you all that into the infrastructure as code space. And so that the core thing that sort of is the most obvious piece of that is that, Pulumi lets you use existing programming languages, so TypeScript or Python or Go or .NET, to ,to build your infrastructure. So instead of you having to write JSON or YAML or HCL, or some of these, very constrained domain-specific languages, you can use the languages that folks, you know, that they're some of the most popular programming languages out there that folks have familiarity with to describe infrastructure and that's both useful because it's familiar, you know, there's languages that aren't a foreign thing to large swaths of developers and then sort of dev ops folks in the industry. But I'd say the biggest, benefit is that it brings to bear the ecosystems that I just mentioned around tooling and package management and, IDEs and that sort of thing.

So all those benefits that you get from those language ecosystems are now the benefits you also get, inside your infrastructure. and then most importantly, like programming language is sort of--the thing that. programming languages are fundamentally, really great at is creating abstractions. Right? I think the key, you know, if there's one thing that programming languages are about, it's, it's giving names to pieces of functionality.
I ended up extracting them away and then putting them in a library and then distributing that library. This is that idea of building reasonable abstractions, is sort of one of the key things that we want to see unlocked in the cloud infrastructure space and kind of, we believe that program languages really help to accelerate that trend.

And so, so we've seen that in practice that, you know, people build really, we build some really rich libraries and then other folks, out there in the community and internally inside, you know, companies that are using Pulumi are building  really rich, reusable libraries, sharing them with new organization and then using that to scale up, you know, what they can build, because I don't have to copy paste thousands of lines of YAML all over the code base.

**Beyang:** Yeah. I mean, that's a, you know, from my experience using it, too. and I certainly, you know, I, I was a little bit skeptical at first. you know, it was actually a teammate of mine, Geoffrey Gilmore, who kind of brought it into our team. But I think once, I had that experience of, you know, writing, writing our Kubernetes cluster configuration as just a bunch of TypeScript.

And you had like auto-complete and all the kind of fancy IDE stuff, it just felt, You know, a lot more natural and intuitive and it's, I feel like it's one of those things that you kind of have to experience, and then you kind of see that like the difference is night and day

**Luke:** Yeah, I agree. And I think it's actually kind of related to some of the conversation about, you know, even what we were talking about with the Go tooling and just having that perspective of, Hey, even if the sort of existing ethos is one around this very simple, lowest common denominator, text-based kind of idea, there can be a lot of value that comes from bringing these richer tools, whether it's, you know, the idea that when I'm typing, you know, even just the AWS API is, is enormous. For example, I think people think of big APIs out there, like the iOS API or the web standards APIs, I'd say AWS is probably bigger than either in terms of the total number of you know, resources and properties that are available to, to manage things within AWS, it's just an absolutely enormous API surface area. And so just having IDE tooling that  exposes help text just in the IDE, as you're typing--it exposes squiggles on things when you are missing some required property.

Like all these little pieces of feedback to then help you to explore and understand and quickly iterate on those things are, are really valuable, in the, in the cloud space. And I think there's something that the existing communities sort of had--had not really seen as important, but I think now we're seeing as, as more folks with a software engineering and developer mindset coming into the cloud space, I think there's an increasing number of folks who are kind of looking for, how do I, how do I get that same level of productivity, reliability, ability to scale up complexity? How do I bring that in? And I think some of it is again, coming from that mindset of, you know, tools and IDEs and programming languages and bringing that into the space.

**Beyang:** In the space of kind of infrastructure configuration management tools or infrastructure as code tools, there's kind of this distinction people draw between declarative and imperative approaches where like imperative is kind of like the Bash script mentality where you're doing like one thing after another and there's kind of like state that you're modifying.

And then there's like, declarative, which, you know, the, the tool that always comes to mind when people say that word is like Terraform, like you just declare kind of the, the infrastructure that you want to appear. And then it figures out how to kind of, realize that for you.  Does Pulumi fall into either of those paradigms?

**Luke:** Yeah I think that's a great question. One of the, one of the sort of key questions a lot of folks ask when they first come to Pulumi and, you know, my view, one of--the thing that is sort of really unique in some sense about Pulumi is that it really tries to get the best of both of those worlds. And I think it tries to show that this isn't an either-or. There is the ability to sort of get what people love about, declarative, and when I say declarative, right. I try to clarify that there's this notion of sort of desired state configuration. Really the, the, the key thing about Terraform and Cloud Formation and, and other desired state models is that the, the thing that you write down is the desired state you want the system to be in.

And then the tool is going to try to get you from the state you are in to that desired state. It's not going to do the set of actions you specify. It's going to say, I know that there's--the current state is this and the desired state is this. So I'm going to, I'm going to take whatever--I'm going to figure out what the minimum way to get there is safely , I'll let you preview that and understand whether you want to take those steps. And then I'm going to go in and do those steps for you. And so this idea of desired state configuration versus kind of imperative modification of this state is, is I think the really key thing that, that Terraform and Cloud Formation other tools like that have, have shown can be really effective in the cloud space.

And there's the question of how do you author that desired state. So do you, do, do you offer that desired state in something like YAML, or do you offer that desired state in--using code that imperatively can build up that graph of what the desired state is? And I think there, you know, my, my feeling is when you have, you know, 10 resources, it's reasonable to think that it's simpler to just write it in YAML or write it in HCL or something like that. you know, there's, there's a small number of these things. You can write them fairly directly. you know, that's, that's at that scale that really fits the job well. But the thing we see is that, especially as folks are moving into modern cloud technologies, things like serverless and containers and especially Kubernetes, the number of resources they're managing, the speed at which those resources are changing is growing up, is, is, is growing incredibly fast. So, you know, it's going from, I've got tens of resources to now I've got in some cases, tens of thousands of resources. And at that scale, you can't just, you know, you can't just have hundreds of thousands or millions of lines of YAML and copy paste stuff around.

Right? You, you have to have some organizing principles at a higher level. And that means you have to have sort of abstractions to tame that and -- abstractions, just, you know, people have tried to do that on top of these, YAML-like things, but, but inevitably, as soon as you try and introduce abstraction, you end up trying to recreate a programming language effectively. And so I think, you know, what our view is, instead of trying to turn YAML and things like that into a programming language, let's take programming languages that we know work well. Let's embrace the idea that, that we can imperatively construct the desired state, but let's still maintain all those benefits of, you know, being a, being a desired state configuration model.

So we think that that, that really can scale up to the complexity of the kind of things people are building now with these modern cloud technologies and at the same time can provide, you know, all this rich tool around that developer experience.

**Beyang:** Yeah, the thing you said about having some sort of imperative programming language to generate a configuration that then you can apply declaratively that kinda --what we actually do--there, there are two places in our code base, where that happens now, actually. Like one is we use Buildkite as a CI service and, you know, you described your like, CI pipeline as a bunch of YAML, but we actually have a like small Go program that generates that YAML for us.

And then that gets applied and becomes a real pipeline. And then, for the Kubernetes cluster, the distribution, This is not so much the case now, but once upon a time, we, we had like a Go program that would also like take in some configuration points and then generate -- spit out a bunch of YAML that then could be, you know, kubectl applied to a running cluster.

So I think, I think you're onto something there. There's something about like the, like at some point there's customization or complexity that you have to capture, in, like describing what you actually want to be applied that is hard to do in kind of like a, declarative DSL. But at the same time you want that kind of guarantee of like, like, I don't want to worry about implicit state that I, I kind of created or affected along the way.

I just want like this, this thing that it spits out this, you know, YAML configuration or whatever is the source of truth. And this is going to be applied to, the cluster. I don't know if I'm making sense there, but uh.

**Luke:** No, I think that's very true. And that pattern you kind of mentioned. I think, you know, when we talk to development teams, I mean, just about everyone out there has had this experience of building a tool which generates config, you know, building, building some software that does use imperative tooling to build whether it's the YAML or HCL or JSON or whatever it is because those formats just don't scale up. You know, as, as, as complexity increases, they are not, they're not human editable formats at certain scales and software is sort of the proven, proven thing that can scale up to tremendous levels of complexity.

You look at, you know, one of the analogies I often make is sort of that these, you know, YAML and HCL and kinda things, they're sort of like the assembly code of, of application development. Right? And, you know, assembly code is great when you're writing hundreds of lines of assembly, you know, had we not invented C and, and all these programming languages that sort of, built on top of that and continue to raise the abstraction level, and built the library, ecosystems that, you know, the C standard library and all the library ecosystems that then came about with Java and these kinds of things.

You know, we would have been stuck reinventing the wheel. We would have been -- scaling up complexity would have been very hard, you know, with assembly. 'Cause you're just copy-pasting stuff. Reusability is much harder, even calling conventions and stuff like that are tough. And so, you know, I kind of think of a similar thing where, you know, with these, with these configuration formats, they, they can work really well at a small scale. And I think the cloud for a lot of people has been small scale, you know, for the last few years. And, and I think a lot of folks are now hitting the point where as they really lean into some of these cloud native technologies, Cloud is not small scale anymore. It's big, it's a intertwined part of how they build and deliver and deploy and manage their software and the lines between the code that they own and the managed services they use inside their cloud provider is becoming increasingly, you know, increasingly intertwined. and so. That is leading them to, you know, it's not okay now to just manage that using assembly code, right. You really do need to use these, these higher level tools to manage them.

**Beyang:** Yeah, I, you know, I kind of get the sense that, managing your infrastructure and the configuration, it's such a painful problem. And there's, there's been a lot of tools that have sprung up, a lot of them in the past, like five, 10 years to kind of deal with that problem. Do you think that the field is going to converge, moving forward?
Like people will kind of standardize on one or maybe a few solutions? Or do you think that, you know, different kind of deployment tools will naturally evolve towards different computing platforms or different, you know, language verticals or ecosystems.

**Luke:** Yeah, I think the cloud infrastructure space is still, you know, It's still, honestly, I mean, even though it's been 10 years since EC2 was launched, I think, I think it's still very early days and I think there's still a lot, a lot changing in the, in the cloud space. and, and so I think there's going to continue to be quite a bit of evolution.

I don't think we're at a point where we're just going to start solidifying into one particular tool. But, but I don't, I don't know exactly where that will go. I think, you know, I think there's a few interesting kind of trends that I see. I see, I think one is this idea that complexity and both total complexity of cloud infrastructure and the rate of change of cloud infrastructure are increasing quite rapidly.
And especially as folks are moving into these kind of relatively newer technologies, which are seeing a ton of adoption now, I think that is it's going to lead to a different class of tools being popular as those become the norm of than was popular kind of over the last five years when running an EC2 VM or two was, was what it meant to use the cloud.

And so I think that is going to drive some change there. And I think, you know, some of it's going to be tools to manage that complexity. Some of it's going to be, other things, but I think the other piece that is interesting is, an increasing sort of shift towards, Taking automation further and further here.
And I think you're starting to see this in some of them in the Kubernetes world, for example, with like the operator pattern. You're seeing folks move from, you know, human in the loop on a lot of these deployment tasks to automated tasks, you know, maybe inside, inside the Kubernetes cluster where, where there's some deployments are being automated via either via CI/CD pipeline or by an operator or something like that.

And so I think there's, there's interesting things that are gonna happen there. I always, hate to say kind of No-Ops. It's sort of this term that gets overused a little bit, cause I think there's no chance that we're going to end up in a world that's really, really no-ops. But I think there is sort of increased levels of automation that are going to be, going to happen just because as you get to this complexity and speed of change, you have to find ways to remove humans from the loop on more of these things and then automate more of these things.

And so I think, you know, for the kind of infrastructure deployment and management space, I do think there's going to be an interesting trend in that direction.

**Beyang:** Yeah, that's interesting. you know, one of the other people we talked to for the show is David Cramer. He's the  creator of Sentry, that application error monitoring tool. And he, he made the prediction that in five years, people weren't going to use Kubernetes anymore, or if they did, it would be hidden in such a way that like, you know, you wouldn't realize it's Kubernetes.

Do you, do you feel the same way, or do you think, you know, like in five years time, a lot of your development team will have to kind of understand like kubectl and, like a lot of the kind of, concepts in Kubernetes.

**Luke:** Yeah. I don't know if five years is a long time, in the cloud space. And I think a lot is going to change over the next five years. I think Kubernetes obviously it's become a huge staple. I think when, you know, when we talk to folks using Pulumi is just the number of organizations that I talk to who are you know, moving towards Kubernetes as their platform of choice for kind of their modern cloud initiatives is really striking. And it is just showing up for kind of almost all the conversations we have with teams about their future cloud direction. So I think, you know, there's definitely, there's definitely gonna be a large, a large move in that direction.

I'd say, you know, in my mind, like I would be disappointed in some sense, if Kubernetes was the, was the end state of this, you know, I sort of fundamentally believe that we, we want to get to a world, which is significantly more developer friendly and democratizes access to these capabilities, to it, to another order of magnitude beyond kind of where Kubernetes is.

I think Kubernetes make some things quite a bit simpler. but, but it really is still not nearly where I would hope we kind of get to in terms of these platforms. And that may happen within the Kubernetes ecosystem. It may happen by something else coming around that--

**Beyang:** Serverless?

**Luke:** It might happen with serverless, and I think, you know, either with serverless itself or with, you know, some of the things that are doing serverless patterns involving within the, within the Kubernetes ecosystem itself.

I sort of my guess is it won't in five years, it won't look exactly like Kubernetes and it won't look exactly like, like serverless, but it will have lots of things. Lots of elements of both of those. and I think there'll be a bit more of a continuum there and, and it will be significantly more focused on the developer experience, not, not so much the kind of operator experience.

I think more of that will fall into the background as you kind of suggested. And we'll see things that empower developers to move quickly and reliably, becoming the platforms that we talk about.

**Beyang:** Makes sense. Before I let you go, I want to get your take on kind of a random question, but, you know, given your background with programming languages, and IDEs, I wanted  to ask you: cloud IDEs, passing fad, or here to stay?

**Luke:** Yeah this is a funny one. I've been sort of involved in various cloud IDE kind of things, for, for for many years. And I'd say, I think I started off being really bullish on cloud IDEs probably, you know, on the order of 10 years ago. and, you know, really thinking that this was the path to go. I think the more time I've spent with them, like, you know, we've, as an industry built really exciting, you know, kind of, you know, incarnations of this idea over, over the years. And. Every time so far, we've kind of seen that they, they aren't the thing that developers end up picking, right. Developers still end up today wanting to fall back into something on their local machine, where they can plug into their whole local toolchain and they can understand the environment they're working in and have complete control over it.

And I, I sort of continue to be sort of to your five year point. It's one of those things where in any near term timeframe, I don't see that changing. And yet I continue to think that over the long term, it sort of has to change in some sense. Like, I think that that, that change is gonna come -- and I don't know what this will exactly look like, but I kind of feel like it'll have to come from something about the developer desktop experience changing fundamentally that, that we no longer think about our machines as -- it's almost like we no longer think about our machines as pets. We think about them more as cattle or something. Something similar to that transition where, you know, we as developers shift the way we think about our, the environments in which we do development in a way, which makes it possible for cloud IDEs.

And it will probably require cloud IDEs being able to offer something fundamentally better that helps people pull across that boundary. And I don't know what that'll be yet, but, I'm excited to, I'm excited to see.

**Beyang:** All right. One final question. If someone listening wants to try Pulumi now, what should they do?

**Luke:** Yeah. So we've got, you know, the, the website at  Pulumi.com. You can go there, click get started, walk through a little tutorial that'll show you  how to usePulumii with, with your favorite cloud, whether that's AWS or Azure or GCP or just raw Kubernetes. And then the Pulumi open source project is github.com/pulumi/pulumi.

All of the core pieces, both including your open source, you can go take a look at the project and engage with the community in the community Slack and let us know what you think.

**Beyang:** My guest today has been Luke Hoban. Luke, thanks for being on the show.

**Luke:** Thanks for having me.
<!-- END TRANSCRIPT -->
