{"expireTime":9007200905229171000,"key":"transformer-remark-markdown-html-0d0b1d194b89b3b809833d967a3f2585-gatsby-remark-autolink-headersgatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-unwrap-imagesgatsby-remark-imagesgatsby-remark-smartypants-","val":"<img src=\"https://storage.googleapis.com/sourcegraph-assets/blog/how-not-to-break-a-search-engine-new.png\" alt=\"Unglamorous engineering\">\n<blockquote>\n<p><em>“In 2020 I flipped the switch to use a completely rewritten parser for\nSourcegraph search queries. It serves tens of thousands of users and processes\nmillions of queries. And after flipping the switch… nothing remarkable\nhappened. Nobody noticed. Zero reports of implementation bugs. Everything had\ngone as planned. I’d pulled off my greatest feat of unglamorous engineering.”</em></p>\n</blockquote>\n<p>Early last year I started rewriting the parser that processes search queries in\nSourcegraph—the bit that users type into the search bar. This component\nprocesses every single input that goes into the search bar when users search\nfor code:</p>\n<img src=\"https://storage.googleapis.com/sourcegraph-assets/about.sourcegraph.com/blog/2021/search-bar.png\" style=\"width: 660px\" alt=\"Code search input bar\">\n<p>When the switch activated the new parser in September 2020, you’d never know\nthat anything had changed. This is an account of the invisible, rigorous\ntesting that ensured a seamless transition.</p>\n<p>The motivation for the change was to introduce standard boolean operators like\n<code class=\"language-text\">and</code>, <code class=\"language-text\">or</code>, and <code class=\"language-text\">not</code> in queries. Sourcegraph had supported some of these\nnotions through regular expressions, but we were missing more general\nfunctionality, and the syntax to accompany it. This new functionality meant\nrewriting the query parser from scratch (I’m going to gloss over why it had to\nbe done from scratch, but just bear with me, this wasn’t a component we could\nretrofit). These boolean operators were a clear product win. I was excited that\na rewrite could later unlock new prospects for our search syntax. I knew these\nwere the goals. But to get to the goal I had to suspend my focus on the shiny\n“feature” part of this work. Something else dwarfed other concerns.</p>\n<p>Sourcegraph’s bread and butter is code search. Every single search query is\ngoing to run through this new code. Bugs in a beta feature are understandable.\nA UI bug may be temporarily excusable. But a bug in the query processing of the\ncore product could spell a lot of trouble. What if previously working\nqueries stopped working? What if they behaved incorrectly? What if an input crashed\nthe server? The point was to support new operators in the query, and I was\ngoing to introduce these, but mentally I was more preoccupied with ensuring\nthat <em>existing queries keep working</em> the way that they should.</p>\n<p>Writing a parser isn’t <em>that</em> difficult. But it’s a different matter to write\none from scratch for a fresh project versus swapping out something that is in\nuse by thousands of users. When the stakes are high, simple things become\nchallenging. This code will need checking and checking again. Not exactly\nglamorous.</p>\n<p>The changes weren’t just about the act of parsing either. The new parser would\nproduce a different internal representation of a query. Trees would represent\nour queries now, no longer just a sequential list of terms. This new\nrepresentation needed to keep working with what our backend internals expect.\nThat, or bugs galore.</p>\n<p>I made up my mind that, as far as I could help it, swapping our parsers wasn’t\ngoing to break Sourcegraph. Not on my account.</p>\n<h2 id=\"How-not-to-break-a-search-engine\" style=\"position:relative;\"><a href=\"#How-not-to-break-a-search-engine\" aria-label=\"How not to break a search engine permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>How not to break a search engine</h2>\n<p>Over the course of development I progressively tested new changes in four\ndistinct ways. I wasn’t following a checklist of things to do. What mattered\nwas that I could convince myself that things worked as expected. I wanted\nto sleep well at night. Testing along these four different dimensions gave me\nconfidence that I could expect few (if any) surprises. In general, the sort of\ntesting for application rewrites or migration is going to depend on the\ncontext. I feel like the steps I took worked well, and they probably generalize\nwell for migrating other systems that accept user input.</p>\n<h3 id=\"Part-1-Unit-testing\" style=\"position:relative;\"><a href=\"#Part-1-Unit-testing\" aria-label=\"Part 1 Unit testing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Part 1: Unit testing</h3>\n<p>Unit testing was the obvious thing to do™ and familiar territory for a lot of\ndevelopers, so I won’t belabor this part. I thought of this as my frontline\ndefense for testing correctness. I reused some of our existing parser tests\n(which served as a rough specification of things to get right) and also added a\nlot of additional tests for new parts of the syntax. You bet there’s test\ncoverage.</p>\n<img src=\"https://storage.googleapis.com/sourcegraph-assets/about.sourcegraph.com/blog/2021/parser-coverage.png\" style=\"width: 300px\" alt=\"Parser file unit test coverage\">\n<h3 id=\"Part-2-Integration-testing\" style=\"position:relative;\"><a href=\"#Part-2-Integration-testing\" aria-label=\"Part 2 Integration testing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Part 2: Integration testing</h3>\n<p>Once I wrote a feature-flagged code path to use the new parser, it was time to\ntest whether Sourcegraph behaved functionally similar. Integration tests ran a\nsearch query through a running instance of the Sourcegraph application and\nchecked whether search results were expected. This testing phase was so\nimportant because the parser produced a new and different internal\nrepresentation. I’d abstracted out a common interface for our backend to access\nthe new data structure under the feature-flagged code path to test on.</p>\n<figure style=\"width: 800px; max-width: 100%; margin: auto;\">\n  <img src=\"https://storage.googleapis.com/sourcegraph-assets/about.sourcegraph.com/blog/2021/integration.png\" alt=\"Integration testing diagram\" style=\"box-shadow: none;\">\n  <i><small>Integration testing abstracts a common interface for our backend\n  to access query values.\n  We test that the backend produces the same search results for\n  simple queries (ones that don't have, e.g., </small></i><small>\n  <code>or</code>\n  <i>-operators), irrespective of whether those values originate from the existing parser's output or the new one.</i></small>\n</figure>\n<br>\n<p>When I got to this part, we didn’t have a good way to run integration tests. We\nhad browser-based end-to-end testing that was onerous to set up, time-consuming\nto run, and brittle. I was desperate for a way to do this more easily and\nquickly, and only really needed to run queries through our backend GraphQL API,\nnot the browser. I wrote a barebones utility to locally run queries through our\nbackend and snapshot the results\n(<a href=\"https://github.com/sourcegraph/sourcegraph/pull/10712\">#10712</a>). This testing\nwas <em>immensely</em> helpful because I could lock in existing expected search\nbehaviors for every new addition. I didn’t want a user to enter a reasonable\nquery and get an unreasonable result. It preempted a bunch of behavioral bugs\nas I tweaked data structures and interfaces.</p>\n<p>At the time there was a parallel effort to add integration testing to our CI,\npartly motivated by the parser rewrite. It wasn’t ready yet. Two months after\nheavily using my local barebones utility, my coworker\n<a href=\"https://twitter.com/jc_unknwon\">@joe</a> brought this testing to our CI. It was a\ngame changer. Now all of our development was subject to this testing, not just\nmy local tinkering. I’d venture that this is probably the most valuable part of\nour search testing infrastructure today. The wild thing is how rock solid it\nis. We get flakes in our CI all the time, but not from this part. For all its\ncomplexity (set up and tear down of a live Sourcegraph instance, repository\ncloning, and running some intensive tests), I can’t recall a single time it’s\nbuckled. I’m amazed every time I think about it. I don’t know how Joe did it,\nbut the thing is just peak unglamorous engineering to me. I imagine it was\npainful to write and test, but I’m so impressed. The wait was worth it and it’s\nbeen catching bugs ever since.</p>\n<h3 id=\"Part-3-Fuzz-testing\" style=\"position:relative;\"><a href=\"#Part-3-Fuzz-testing\" aria-label=\"Part 3 Fuzz testing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Part 3: Fuzz testing</h3>\n<p>If unit testing is the appetizer and integration testing the main course, fuzz\ntesting is the dessert. Fuzz testing would reveal rare, corner-case inputs that\ncrash the server violently. They’re kind of fun to discover. I used the\nexcellent <a href=\"https://github.com/dvyukov/go-fuzz\">dyukov/go-fuzz</a> tool and found\nit’s a breeze to set up.</p>\n<p>I ran local fuzz jobs for a couple of hours here and there throughout\ndevelopment. Continuous fuzzing is nice to have, but local fuzzing was good\nenough. This part caught three bugs, two of which caused a <code class=\"language-text\">panic</code> that broke an\nassertion when concatenating certain patterns with unbalanced parentheses or\nunconventional unicode space characters\n(<a href=\"https://github.com/sourcegraph/sourcegraph/pull/12457\">#12457</a>). The other was\ncaused by an out-of-bound access for patterns that ending with a trailing <code class=\"language-text\">\\</code>\n(<a href=\"https://github.com/sourcegraph/sourcegraph/pull/12463\">#12463</a>). This was on an\nexperimental feature-flagged code path. No biggie. I was happy to find only\nthese, and that they were fairly low profile. More than anything, fuzz testing\ngave me peace of mind that things were holding up.</p>\n<h3 id=\"Part-4-Differential-testing\" style=\"position:relative;\"><a href=\"#Part-4-Differential-testing\" aria-label=\"Part 4 Differential testing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Part 4: Differential testing</h3>\n<p>Differential testing came towards the end of the migration work, when I was\nready to flip the switch for good.<a href=\"#footnote-1\"><sup>1</sup></a> The\nnew parser had been active under a feature flag on our dogfood instance and\nsome customer instances, but it was time to make it the default. The point of\nno return. For more peace of mind, I wanted assurance that the data structure\noutput of the new parser was <em>interpreted</em> the same way as the old one on a\nlarger set of queries than our integration tests covered. I collected a couple\nthousand queries from the fuzz testing and live queries on our dogfood\ninstance. I then ran these through a utility that parses the input with both\nnew and old parsers, converts the two outputs to a unified data structure that\nencodes the query properties, and then diffs the two outputs. Any difference\nimplied that the query output was interpreted differently by the backend and a\npotential bug.</p>\n<p>I caught one good bug with differential testing, where the previous parser ran\na heuristic step that escapes a trailing dangling parenthesis for regular\nexpressions. The heuristic interpreted an invalid regular expression like\n<code class=\"language-text\">foo.*(</code> as <code class=\"language-text\">foo.*\\(</code>. This is to avoid throwing a syntax error at the user and\ninstead yield matches for what they likely intended\n(<a href=\"https://github.com/sourcegraph/sourcegraph/issues/12733\">#12733</a>). There were\nthree other differences that turned out to be fairly inconsequential, but nice\nto catch. These bugs were about differing interpretations of reserved syntax.\nFor example, the new reserved syntax <code class=\"language-text\">or</code> in the new parser had special\nmeaning. The old parser didn’t ascribe any special meaning to <code class=\"language-text\">or</code>, and this\n(intentional) difference reflected in the testing.</p>\n<h2 id=\"The-switch-is-flipped\" style=\"position:relative;\"><a href=\"#The-switch-is-flipped\" aria-label=\"The switch is flipped permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>The switch is flipped</h2>\n<p>In 2020 I flipped the switch to use the completely rewritten parser for\nSourcegraph search queries. It serves tens of thousands of users and processes\nmillions of queries. And after flipping the switch… nothing remarkable\nhappened. Nobody noticed. Zero reports of implementation bugs. Everything had\ngone as planned. I’d pulled off my greatest feat of unglamorous engineering.</p>\n<p>Hardly anyone could appreciate how months of effort culminated in an\nincident-free transition. That was, after all, expected. I mean, how do you\nderive appreciation from users, peers, or managers when the point was for no\none to notice anything significant had changed; when there’s no perceptible\ndelta?</p>\n<h2 id=\"Value-in-the-unseen-and-unspoken\" style=\"position:relative;\"><a href=\"#Value-in-the-unseen-and-unspoken\" aria-label=\"Value in the unseen and unspoken permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Value in the unseen and unspoken</h2>\n<p>There’s unglamorous engineering in the software all around us. For all its lack\nof recognition, I wish we grasped its value a bit better. I’m reminded of a\ntweet by a former colleague who researched donations for open source projects:</p>\n<blockquote class=\"twitter-tweet tw-align-center\" data-conversation=\"none\"><p lang=\"en\" dir=\"ltr\">I can tell you from some informal interviews we did outside that paper, that people spend the money on gruntwork — the stuff that’s fun they’re more likely to do anyway, money or not.</p>&mdash; Bogdan Vasilescu (@b_vasilescu) <a href=\"https://twitter.com/b_vasilescu/status/1279199236094132227?ref_src=twsrc%5Etfw\">July 3, 2020</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n<p>This suggests that gruntwork, if not glamorous, is certainly valuable (and\nperhaps, even disproportionately so). At the same time, I wouldn’t necessarily\ncall unglamorous engineering thankless. Your close peers may be very\nthankful for a component rewrite or code refactor (I know I am), but no amount\nof gratitude will make unglamorous work glamorous. It simply has to get done in\nspite of whether there’s a desire to tackle it, or some incentive or\nrecognition. And sometimes you might be the only one who knows it. Maybe it’s\njust part of writing code. At times you need to wear the hat of a hygiene\nengineer.<a href=\"#footnote-2\"><sup>2</sup></a> A developer-janitor. A code plumber. And that\ncost can feel very personal.</p>\n<p>The lamentable part of the unglamorous engineer’s work is that there’s little\naccount of these feats. Technical media and blogs are prone to talk about\nfeatures or intellectual explorations. The new and shiny is naturally engaging.\nBut I also want to hear about that impressive engineering feat that no one\nnoticed. The one where a developer or team pulled off some tectonic shift in a\ncodebase, everyone oblivious except themselves.</p>\n<h2 id=\"New-capabilities-while-steadily-transitioning-the-old\" style=\"position:relative;\"><a href=\"#New-capabilities-while-steadily-transitioning-the-old\" aria-label=\"New capabilities while steadily transitioning the old permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>New capabilities while steadily transitioning the old</h2>\n<p>Sourcegraph supports more combinations of operators now. And nothing outright\nbroke in order to get there. In hindsight, did I go overboard on some parts and\nwould I have done things differently? In short, no. New functionality was\nrolled out iteratively and quickly in phases that users could freely try along\nthe way. I also enabled new implementations on our dogfood instance as things\nmatured. The core implementation and testing probably took only one or two\nmonths, but crossing the point of no return and removing the fallback was a\nslow and thorough process. If I sensed that excessive testing was stunting\nprogress and delaying the planned timeline, I might feel differently, but I\nnever got that sense. And to be clear, I did more than rewriting and testing\nparsers in that six-month time frame, but that’s off topic. Our current state\nisn’t perfect, there’s more to tweak—but when the previous code was finally\ndropped, it wasn’t one of those typical anxiety-inducing rushes to hit a\ndeadline. It felt good and it felt right.</p>\n<h2 id=\"In-closing-Unglamorous-engineering-and-you\" style=\"position:relative;\"><a href=\"#In-closing-Unglamorous-engineering-and-you\" aria-label=\"In closing Unglamorous engineering and you permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>In closing: Unglamorous engineering and you</h2>\n<p>We have a ton of work to do around search query <em>usability</em> (story for another\nday). Users are often surprised by how searches behave, even though the\nbehavior is intentional. But a surprised or mildly inconvenienced user is a far\ncry from releasing a bug that takes down a company’s instance. Severe bugs\ncascade into out-of-band releases for our distribution team and upgrades for\ncustomers. They also tend to have a latent effect on engineer productivity (in\nthis case, mine) when bugs later impose context-switches to fix\nthings—conceptually big costs that I wanted to avoid. All of these\nconsiderations, code changes, and heaps of testing happened in the pursuit of\nan unglamorous outcome while two, maybe three, engineers reviewed the code to\nsee it play out. I know this isn’t an isolated thing. I get faint hints of\nother engineers at Sourcegraph doing momentous but unglamorous things that most\nof the organization is blissfully unaware of. And the Twitterverse suggests\nthere’s more of it happening in software all around us:</p>\n<blockquote class=\"twitter-tweet tw-align-center\"><p lang=\"en\" dir=\"ltr\">A huge problem in software companies is that large new features get praise, promotions, accolades... while migrating off a legacy system, increasing performance 2,4,10X, or reducing error rates, pages, or alerts by X% is often only recognized by peers and not leadership.</p>&mdash; Dan Mayer (@danmayer) <a href=\"https://twitter.com/danmayer/status/1395564252308541440?ref_src=twsrc%5Etfw\">May 21, 2021</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n<p>I empathize with the engineers who don’t have an audience for their unglamorous\nwork, who want to say, “I did A Thing, there’s nothing to see, but more people\nshould care. Let me tell you about it!” I like my portion of showpiece\nengineering, don’t get me wrong. But shouldn’t doing the necessary, unglamorous\nwork be a marketable skill as well? Where’s the signage that reads “Unglamorous\nengineers wanted. Will pay handsomely”? I hope you’re encouraged to share what\nyou’ve pulled off.</p>\n<hr>\n<p><a id=\"footnote-1\"><sup>1</sup><small>If you’ve been following along, here’s\nwhere our three-course meal analogy breaks down. Let’s just say\ndifferential testing is the surprise food inspector hanging out in the\nkitchen.</small></a></p>\n<p><a id=\"footnote-2\"><sup>2</sup><small>Amusingly, I once met an engineer from a\nwell-known tech company who used this title on their business card.</small></a></p>\n<hr>\n<p><strong>About the author</strong></p>\n<p><em><a href=\"https://twitter.com/rvtond\">Rijnard</a> is interested in developing new ways to\nsearch, manipulate, and fix code. He holds a PhD in Computer Science from\nCarnegie Mellon University, where he researched automated bug fixing. He enjoys\nfundamental research but also wants to make research ideas a reality in\npractice. That’s why he currently works at Sourcegraph, where he applies his\nresearch background to develop new tools and techniques for large-scale code\nsearch and automated refactoring.</em></p>\n<p><small>Acks: Thanks <a href=\"https://handbook.sourcegraph.com/team#rebecca-dodd\">Rebecca Dodd</a> and <a href=\"https://twitter.com/camdendcheek\">Camden Cheek</a> for feedback on the content of this post.</small></p>\n<h3 id=\"More-posts-like-this\" style=\"position:relative;\"><a href=\"#More-posts-like-this\" aria-label=\"More posts like this permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>More posts like this</h3>\n<ul>\n<li><a href=\"/blog/ex-googler-guide-dev-tools/\">An ex-Googler’s guide to dev tools</a></li>\n<li><a href=\"/blog/zoekt-memory-optimizations-for-sourcegraph-cloud/\">A 5x reduction in RAM usage with Zoekt memory optimizations</a></li>\n<li><a href=\"/blog/optimizing-a-code-intel-commit-graph/\">Optimizing a code intelligence commit graph</a></li>\n</ul>"}