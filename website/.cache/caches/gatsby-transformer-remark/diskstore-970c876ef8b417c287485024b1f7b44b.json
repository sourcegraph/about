{"expireTime":9007200905229171000,"key":"transformer-remark-markdown-html-f393fe42f85e3fea7b35e31336c1ff60-gatsby-remark-autolink-headersgatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-unwrap-imagesgatsby-remark-imagesgatsby-remark-smartypants-","val":"<p>We’re introducing a new way to search code at Sourcegraph with structural code\nsearch. Structural code search lets you match nested expressions and whole code\nblocks that can be difficult or awkward to match using regular expressions.</p>\n<h2 id=\"What-is-structural-code-search\" style=\"position:relative;\"><a href=\"#What-is-structural-code-search\" aria-label=\"What is structural code search permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>What <em>is</em> structural code search?</h2>\n<p>Structural code search is the idea that you can search for <em>syntactic\nstructures</em> in code that correspond more closely to a program’s underlying\nconcrete syntax tree (or parse tree). For example, <code class=\"language-text\">for</code> <a href=\"https://doc.rust-lang.org/1.2.0/book/for-loops.html\">loops in\nRust</a> look something like\nthis:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">for</span> var <span class=\"token keyword\">in</span> expression <span class=\"token punctuation\">{</span>\n    code\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The <code class=\"language-text\">code</code> block can contain nested <code class=\"language-text\">for</code> loops, <code class=\"language-text\">if</code> statements, and so on. To\nmatch all of the <code class=\"language-text\">code</code> block contents for these expressions, and search for\npatterns inside them, a search engine must understand that <code class=\"language-text\">code</code> exists\ninside the <em>balanced</em> braces <code class=\"language-text\">{ ... }</code>. Regular expressions can go a long way to\nmatch such syntactic structures but they are <a href=\"https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags\">not\nideal</a>.\nIn practice we use <em>parsing</em> to interpret and convert syntax for nested\nexpressions like <code class=\"language-text\">{...}</code> into trees, which encode richer structural properties\nthan the textual representation.</p>\n<p><img src=\"/blog/structural-search-nested-expressions.png\" alt=\"Nested expressions figure\"> Figure 1: Nested\nexpressions can expand inside code blocks. Parsing converts nested expressions\ninto tree data structures.</p>\n<p>Most code search today is not based on true parsing or tree data structures.\nInstead, we use literal strings or regular expressions which is good enough\nfor many kinds of searches. But these methods make it tricky to match precisely\non blocks or expressions that can expand inside statements like the loop\nin Figure 1. We could more easily and precisely search for richer syntactic\npatterns if today’s search tools <em>also</em> treated code as syntax trees, and\nthat’s the key idea behind structural search.</p>\n<p>Many neat developer and compiler tools already exist for querying or\nmatching tree structures (see <a href=\"#additional-resources\">additional resources</a>\nat the end of this post!). But none are available at your fingertips, just\nseconds away from running on some of today’s largest and most popular\ncodebases. That is why we are happy to announce that Sourcegraph now supports a\nfirst release of structural search available at scale, for nearly every\nlanguage, directly from your browser.</p>\n<h2 id=\"Examples-Show-me-examples\" style=\"position:relative;\"><a href=\"#Examples-Show-me-examples\" aria-label=\"Examples Show me examples permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Examples! Show me examples!</h2>\n<p>Let’s look for things in the Linux kernel. After all, why not show\nstructural search working on one of the largest and most popular projects in\nopen source software?</p>\n<p>One important function is <code class=\"language-text\">copy_from_user</code>, which copies content from userspace\nmemory into the kernelspace memory. This function has a history of <a href=\"https://www.defcon.org/images/defcon-19/dc-19-presentations/Cook/DEFCON-19-Cook-Kernel-Exploitation.pdf\">careful\nauditing</a>\nbecause incorrect uses can (and have) lead to vulnerabilities. We can find all\n<code class=\"language-text\">copy_from_user</code> calls with a query like <code class=\"language-text\">copy_from_user(:[args])</code>. Try it\nlive (the <svg class=\"mdi-icon \" style=\"border:1px solid #2f9cf1; border-radius: 2px; fill:#2b2b2b; background:#cbd4e2\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\"><path d=\"M15,4V6H18V18H15V20H20V4M4,4V20H9V18H6V6H9V4H4Z\"></path></svg> toggle means structural search is active):</p>\n<div style=\"padding-left: 2rem\">\n<p>🔎 <a href=\"https://sourcegraph.com/search?q=repo:%5Egithub%5C.com/torvalds/linux%24+copy_from_user%28:%5Bargs%5D%29&#x26;patternType=structural\">copy_from_user(:[args])</a></p>\n</div>\n<p>The <code class=\"language-text\">:[args]</code> syntax is a structural hole that matches all text between\nbalanced parentheses. The <code class=\"language-text\">args</code> part is just a descriptive identifier. We\nsupport <a href=\"https://comby.dev/#match-syntax\">comby syntax</a>, which is currently the\nunderlying engine behind structural search. You can find out more about the\nmatch syntax in our <a href=\"https://docs.sourcegraph.com/code_search/reference/structural\">usage\ndocs</a>, but for now it’s\nenough to just follow along this blog post!</p>\n<p>Of course, we <em>could</em> have run a simpler regex search for the prefix with\nsomething like\n<a href=\"https://sourcegraph.com/search?q=repo:%5Egithub%5C.com/torvalds/linux%24+copy_from_user%28+lang:c+&#x26;patternType=literal\">copy_from_user(</a>\nand get results more quickly, and sometimes that’s the right thing to do.</p>\n<p>But in other cases we can do more interesting things with structural search\nthat become awkward otherwise. For example, one result for the above query\nis:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token function\">copy_from_user</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>txc<span class=\"token punctuation\">.</span>tick<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>txc_p<span class=\"token operator\">-></span>tick<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">timex32</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span>\n\t\t\t   <span class=\"token function\">offsetof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">timex32</span><span class=\"token punctuation\">,</span> tick<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>where the argument spans multiple lines. By default, <code class=\"language-text\">:[hole]</code> syntax matches\nacross multiple lines just like code structures can. An interesting thing about\nthe call above is that it calculates the size of memory using <code class=\"language-text\">sizeof(...) -\n...</code>.  Calculating and checking the size of memory to copy can be more\nerror-prone than simple or static values. So, one thing we could check is\nwhether there are other calls that calculate the size of memory in a similar way to the\nabove, using subtraction and <code class=\"language-text\">sizeof</code>:</p>\n<div style=\"padding-left: 2rem\">\n<p>🔎 <a href=\"https://sourcegraph.com/search?q=repo:%5Egithub%5C.com/torvalds/linux%24+copy_from_user%28:%5Bdst%5D%2C+:%5B_%5D%2C+sizeof%28:%5B_%5D%29+-+:%5B_%5D%29&#x26;patternType=structural\">copy_from_user(:[dst], :[src], sizeof(:[_]) -\n:[_])</a></p>\n</div>\n<p>This query breaks up the original <code class=\"language-text\">:[args]</code> hole into holes for the destination\nbuffer <code class=\"language-text\">dst</code>, source buffer <code class=\"language-text\">src</code>, and the calculation for the memory size. The\n<code class=\"language-text\">:[_]</code> syntax is just a hole that we don’t particularly care to name. This\nquery finds just a handful of results, so this is a rather uncommon pattern in\nthe code base!</p>\n<p>Structural search can also identify patterns to clean up. For example, one <a href=\"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=1fbc9f46a024535d95c3d5f136901decd86b109e\">cleanup patch</a> in the kernel looks like this:</p>\n<img src=\"/blog/structural-search-linux-cleanup-patch.png\" alt=\"Linux clean up patch\">\n<p>Here’s a query to easily find more of these patterns:</p>\n<div style=\"padding-left: 2rem\">\n<p>🔎 <a href=\"https://sourcegraph.com/search?q=repo:%5Egithub%5C.com/torvalds/linux%24+list_del%28:%5Bx%5D%29%3B+list_add%28:%5Bx%5D%2C+:%5B_%5D%29&#x26;patternType=structural\">list_del(:[x]); list_add(:[x], :[_])</a></p>\n</div>\n<p>This time, we’re using the same identifier <code class=\"language-text\">:[x]</code> twice, to make sure that the\nargument is the same for both <code class=\"language-text\">list_del</code> and <code class=\"language-text\">list_add</code> calls. We could choose\nany identifier, except for <code class=\"language-text\">:[_]</code>, which is just a placeholder. The whitespace\nbetween the calls is interpreted to possibly include newlines, so there’s no\nissue matching these calls across newlines.</p>\n<p>Do note that structural search is purely syntactic, so there are some matches\nthat cannot cleaned up:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">list_empty</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>page<span class=\"token operator\">-></span>lru<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token function\">list_del</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>page<span class=\"token operator\">-></span>lru<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token function\">list_add</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>page<span class=\"token operator\">-></span>lru<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>pool<span class=\"token operator\">-></span>lru<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>In this case, the problem is that the <code class=\"language-text\">list_del</code> call is in scope of the <code class=\"language-text\">if</code>\nblock. However, the majority of matches carry our intended meaning. In the\nfuture, we are introducing <a href=\"#whats-next-for-structural-search\">rules</a> to refine\nqueries further, giving you greater control for avoiding unintended matches.</p>\n<p>Structural search works on practically all languages, and understands the basic\nsyntactic structures for them (like strings, comments, and code blocks). Here’s\na short list that gives just a taste of some patterns you can try out:</p>\n<p><strong>Java</strong>. Find try-catch-finally statements where the catch statement has no body (the <code class=\"language-text\">catch</code> clause could be omitted)</p>\n<div style=\"padding-left: 2rem\">\n<p>🔎 <a href=\"https://sourcegraph.com/search?q=repo:%5Egithub%5C.com/elastic/elasticsearch%24+try+%7B:%5B_%5D%7D+catch+%28:%5Be%5D%29+%7B+%7D+finally+%7B:%5B_%5D%7D+lang:java&#x26;patternType=structural\">try {:[_]} catch (:[_]) { } finally {:[_]}</a></p>\n</div>\n<p><strong>Python</strong>. Find old-style string formatted <code class=\"language-text\">print</code> statements</p>\n<div style=\"padding-left: 2rem\">\n<p>🔎 <a href=\"https://sourcegraph.com/search?q=repo:%5Egithub%5C.com/django/django%24+print%28%22:%5Bargs%5D%22+%25+:%5Bv%5D%29+lang:python&#x26;patternType=structural\">print(”:[string]” % :[args])</a></p>\n</div>\n<p><strong>Rust</strong>. Find chained <code class=\"language-text\">filter(...).next()</code> that could simplified to <code class=\"language-text\">.find(...)</code> (based on <a href=\"https://rust-lang.github.io/rust-clippy/master/index.html#filter_next\">lint</a>)</p>\n<div style=\"padding-left: 2rem\">\n<p>🔎 <a href=\"https://sourcegraph.com/search?q=repo:%5Egithub%5C.com/openethereum/openethereum%24++.filter%28:%5B_%5D%29.next%28%29&#x26;patternType=structural\">.filter(:[_]).next()</a> and <a href=\"https://sourcegraph.com/search?q=repo:%5Egithub%5C.com/openethereum/openethereum%24+.filter%28:%5B_%5D%29+.next%28%29&#x26;patternType=structural\">.filter(:[_]) .next()</a> (the latter matches across newlines)</p>\n</div>\n<p><strong>ReactJS</strong>. Look for opportunities to optimize away arrow functions (see the <a href=\"https://reactjs.org/docs/faq-functions.html#arrow-function-in-render\">React FAQ</a>)</p>\n<div style=\"padding-left: 2rem\">\n<p>🔎 <a href=\"https://sourcegraph.com/search?q=repo:%5Egithub%5C.com/withspectrum/spectrum%24+:%5B%5Bprop%5D%5D%3D%7B%28%29+%3D%3E+:%5Bfn%5D%28%29%7D&#x26;patternType=structural\">:[[prop]]={() => :[fn]()}</a></p>\n</div>\n<p><strong>Go</strong>. Find <code class=\"language-text\">.type(...)</code> switches that contain a <code class=\"language-text\">nil:</code> case</p>\n<div style=\"padding-left: 2rem\">\n<p>🔎 <a href=\"https://sourcegraph.com/search?q=repo:%5Egithub%5C.com/golang/go%24+switch+:%5B%5Bv%5D%5D+:%3D+:%5Bx%5D.%28type%29+%7B:%5B_%5D+case+nil:+:%5B_%5D%7D+lang:go+&#x26;patternType=structural\">switch :[[v]] := :[x].(type) {:[_] case nil: :[_]}</a></p>\n</div>\n<p><strong>Clojure</strong>. Find <code class=\"language-text\">cond</code> expressions with an <code class=\"language-text\">:else nil</code> branch at the end</p>\n<div style=\"padding-left: 2rem\">\n<p>🔎 <a href=\"https://sourcegraph.com/search?q=repo:%5Egithub%5C.com/LightTable/LightTable%24+%28cond+:%5B_%5D+:else+nil%29+lang:clojure&#x26;patternType=structural\">(cond :[_] :else nil)</a></p>\n</div>\n<p><strong>Dart</strong>. Find <code class=\"language-text\">Image.asset</code> constructors in the Flutter API where width is initialized to <code class=\"language-text\">100</code></p>\n<div style=\"padding-left: 2rem\">\n<p>🔎 <a href=\"https://sourcegraph.com/search?q=repo:%5Egithub%5C.com/flutter/flutter%24+Image.asset%28:%5B_%5D+width:+100%2C+:%5B_%5D%29+lang:dart&#x26;patternType=structural\">Image.asset(:[_] width: 100, :[_])</a></p>\n</div>\n<h2 id=\"Youre-ready-to-try-it-yourself\" style=\"position:relative;\"><a href=\"#Youre-ready-to-try-it-yourself\" aria-label=\"Youre ready to try it yourself permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>You’re ready to try it yourself</h2>\n<p>*<em>Here are a couple of things to keep in mind</em></p>\n<ul>\n<li>Structural search on <a href=\"https://sourcegraph.com/search?q=&#x26;patternType=structural\">sourcegraph.com</a> is only enabled for roughly the top\n10,000 most popular repositories on GitHub, and on the most recent commit of\nthe default branch. We plan to open it up to all mirrored repositories and you\ncan <a href=\"#whats-next-for-structural-search\">help make that happen faster</a>.</li>\n<li>You can <a href=\"https://docs.sourcegraph.com/#quickstart\">set up Sourcegraph\nlocally</a> for your own code or any\nother repository you’d like and get all of the structural search goodness.\nRunning locally will also likely be faster than using <a href=\"https://sourcegraph.com/search?q=&#x26;patternType=structural\">sourcegraph.com</a>.</li>\n<li>You might be running structural search for the first time on a repo! 😎 If\nyour query times out, give the page a refresh because we’re probably warming up\nthe cache for you.</li>\n<li>See our <a href=\"https://docs.sourcegraph.com/code_search/reference/structural\">usage\ndocumentation</a> for more\nhelp and the <a href=\"https://comby.dev/#faq\">comby FAQ</a> for more details and known\nlimitations of the matching engine.</li>\n</ul>\n<p>*<em>A quick note on regular expressions: How is structural search different?</em></p>\n<p>Structural search is not a replacement for regexp search. It’s another tool in\nyour toolkit that works well for matching blocks of code or expressions, and\nsimplifies catching buggy syntactic patterns. If you only want to find a simple\nstring or pattern, consider using Sourcegraph’s literal or regexp\n<a href=\"https://sourcegraph.com/search\">search</a>, because these queries are typically\nmuch faster! For a more detailed breakdown, see the short comparison at the <a href=\"#structural-search-vs-more-traditional-text-search\">end\nof this post</a>.</p>\n<p>That’s it for now. You’ll find some additional resources and\ndiscussion below if you’re interested in reading more. Happy searching!</p>\n<hr>\n<h3 id=\"Additional-resources\" style=\"position:relative;\"><a href=\"#Additional-resources\" aria-label=\"Additional resources permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Additional resources</h3>\n<p>There is an immense amount of existing parsing and query tools for syntax\ntrees. Most compilers today offer a library or visitor framework, and linters\nor static analyzers may build on them to implement checks. Here is a\nnon-exhaustive short list of tools related to structural search and matching\nthat you may be familiar with or find interesting:</p>\n<ul>\n<li>IntelliJ IDE support for structural search and replace, or <code class=\"language-text\">SSR</code> [<a href=\"https://www.jetbrains.com/help/idea/structural-search-and-replace.html\">1</a>]</li>\n<li>Coccinelle for C code [<a href=\"http://coccinelle.lip6.fr/\">1</a>]. Our list example above is taken from the Coccinelle work, and there are <a href=\"http://coccinelle.lip6.fr/impact_linux.php\">many more patterns</a> to browse through and try out!</li>\n<li><code class=\"language-text\">Sgrep</code>, or Syntactical grep (multiple languages) [<a href=\"https://github.com/facebookarchive/pfff/wiki/Sgrep\">1</a>], [<a href=\"https://github.com/returntocorp/bento/blob/master/SGREP-README.md\">2</a>]</li>\n<li><code class=\"language-text\">tree-sitter</code>, parsing and query framework (multiple languages) [<a href=\"https://github.com/tree-sitter/tree-sitter\">1</a>]</li>\n<li><code class=\"language-text\">gogrep</code> for declaratively matching Go syntax trees [<a href=\"https://github.com/mvdan/gogrep\">1</a>]</li>\n<li><code class=\"language-text\">Spoon</code> for declaratively matching Java code [<a href=\"http://spoon.gforge.inria.fr/matcher.html\">1</a>], [<a href=\"http://spoon.gforge.inria.fr/pattern.html\">2</a>]</li>\n<li><code class=\"language-text\">Spoofax</code>, AST querying using the Spoofax Language Workbench (multiple languages) [<a href=\"http://www.metaborg.org/en/latest/source/langdev/meta/lang/flowspec/stratego-api.html#querying-analysis\">1</a>]</li>\n<li><code class=\"language-text\">CodeQL</code>, querying tree and graph properties for a number of poular languages [<a href=\"https://securitylab.github.com/tools/codeql\">1</a>]</li>\n</ul>\n<p>At Sourcegraph we’re continually looking to improve developer tools, and to\nintegrate richer search functionality. If you find these tools or others\nvaluable, share your thoughts with us at <a href=\"mailto:feedback@sourcegraph.com\">feedback@sourcegraph.com</a>.</p>\n<hr>\n<h3 id=\"Structural-search-vs-more-traditional-text-search\" style=\"position:relative;\"><a href=\"#Structural-search-vs-more-traditional-text-search\" aria-label=\"Structural search vs more traditional text search permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Structural search vs. more traditional text search</h3>\n<p>Here are some key differences and comparisons to regexp-based text search:</p>\n<ul>\n<li>Structural search is language-aware. For example, it understands certain pieces of syntax for code blocks, string delimiters, and comments. The language can be forced by specifying the <code class=\"language-text\">lang:</code> filter. If omitted, we perform a best-effort to infer the language based on matching file extensions, or fall back to a generic structural matcher.</li>\n<li><code class=\"language-text\">:[hole]</code> syntax matches across multiple lines by default.</li>\n<li>Whitespace matching is fuzzy: a space in the pattern will match contiguous\nwhitespace including newlines in the code.</li>\n<li>Delimiters like <code class=\"language-text\">{}</code>, <code class=\"language-text\">[]</code>, <code class=\"language-text\">()</code> are expected to <em>always</em> be balanced\n(depending on language). For example, a dangling parenthesis in Java is\nconsidered a syntax error and can’t be matched. A dangling delimiter in the\npattern implies a syntax error (prefer regexp search if you want to match\ndangling delimiters).</li>\n<li>Built-in equality constraints when using the same identifier in patterns like\n<code class=\"language-text\">foo(:[x], :[x])</code>. This is similar to, e.g., backreferences in regular\nexpressions.</li>\n<li>No explicit support for matching regexp character classes like <code class=\"language-text\">\\d+</code> yet.</li>\n</ul>\n<p>For a complete overview, refer to <a href=\"https://comby.dev\">comby.dev</a>.</p>\n<hr>\n<h2 id=\"Feedback\" style=\"position:relative;\"><a href=\"#Feedback\" aria-label=\"Feedback permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Feedback</h2>\n<ul>\n<li>Have a usage question or suggestion about structural search? <a href=\"https://twitter.com/sourcegraph\">Send us a tweet</a> or e-mail us at <a href=\"mailto:feedback@sourcegraph.com\">feedback@sourcegraph.com</a></li>\n<li>Run into a bug? <a href=\"https://github.com/sourcegraph/sourcegraph/issues/new?assignees=&#x26;labels=&#x26;template=bug_report.md&#x26;title=\">Create an issue on GitHub</a></li>\n</ul>"}