{"expireTime":9007200905229171000,"key":"transformer-remark-markdown-html-9c239769b125c920b686a16fa3713e21-gatsby-remark-autolink-headersgatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-unwrap-imagesgatsby-remark-imagesgatsby-remark-smartypants-","val":"<p>So much of what we do as programmers boils down to automating the tedium out of our work. We’d like\nto spend our lives focusing on the design of beautiful abstractions and algorithms, but before we\ncan get to that, we have to do the dirty work—and do it quickly.</p>\n<p>Whether you are a newbie or a seasoned engineer, chances are that you struggle with day-to-day tasks\nthat seem to take longer than they should. One such recurring challenge is <strong>find and replace</strong>.</p>\n<p>Find and replace encompasses a huge variety of renames, refactors, and transformations that you\nmight want to apply in code. To name just a few examples:</p>\n<ul>\n<li>Making a change to a public API and updating downstream consumers</li>\n<li>Changing a function signature and updating every call site</li>\n<li>Converting a bunch of data in one format to another (e.g., XML to JSON)</li>\n<li>Identifying and fixing common anti-patterns to improve code quality</li>\n</ul>\n<p>Doing any of these by hand would be mind-numbing. For assistance, you can turn to a wide variety of\nfind-and-replace tools. But there are so many tools, with varying degrees of applicability,\nexpressivity, ease-of-use, ease-of-learning, and scalability. How do you pick the right one and\nwhere do you begin?</p>\n<p>You may go through a progression like this:</p>\n<style>\ntable.brain {\n    table-layout: fixed;\n    vertical-align: middle;\n    border: 0;\n}\ntable.brain td {\n    vertical-align: middle;\n    border: 0;\n}\ntable.brain td img {\n    margin: 0;\n    float: right;\n}\n</style>\n<table class=\"brain\">\n  <tbody><tr>\n    <td>\n      <img src=\"https://storage.googleapis.com/about.sourcegraph.com/blog/a-programmers-guide-to-find-and-replace/brain1.jpg\">\n    </td>\n    <td>\n    You start with manual find-replace, maybe with some regex in your editor.\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <img src=\"https://storage.googleapis.com/about.sourcegraph.com/blog/a-programmers-guide-to-find-and-replace/brain2.jpg\">\n    </td>\n    <td>\n    You bite the bullet and finally learn <code class=\"language-text\">grep</code> and <code class=\"language-text\">sed</code>,\n    so you're no longer constrained by the bounds of your editor.\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <img src=\"https://storage.googleapis.com/about.sourcegraph.com/blog/a-programmers-guide-to-find-and-replace/brain3.jpg\">\n    </td>\n    <td>\n    You get annoyed wth <code class=\"language-text\">grep</code> and <code class=\"language-text\">sed</code> and find\n    tools like ripgrep (<code class=\"language-text\">rg</code>) and <code class=\"language-text\">codemod</code>.\n    Maybe you dive down the rabbit hole of parsers. Powerful—but it's a slog reading AST specs and writing tree traversers.\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <img src=\"https://storage.googleapis.com/about.sourcegraph.com/blog/a-programmers-guide-to-find-and-replace/brain4.jpg\">\n    </td>\n    <td>\n    In your quest for ever greater efficiency, you discover <code class=\"language-text\">comby</code>, an awesome new pattern-matching language for code.\n    You use it to execute really really large crucial changes across your organization's code.\n    </td>\n  </tr>\n</tbody></table>\n<p>In this post, we’ll cover all the legs of this journey. If you’re new to all this, you’ll get an\nintroduction to many tools that you can use to slay monsters of tedium along your programming\njourney. If you’re already a veteran Odysseus, feel free to skip to the last two parts of this post,\ncovering Comby and large-scale code change campaigns.</p>\n<p>Here’s what we’ll cover:</p>\n<ol>\n<li>\n<p><a href=\"#find-and-replace-in-your-editor\">Find and replace in your editor</a></p>\n<ul>\n<li><a href=\"#regular-expressions\">Regular expressions</a></li>\n<li><a href=\"#keyboard-macros-and-multiselect\">Keyboard macros and multiselect</a></li>\n<li><a href=\"#semantic-refactoring\">Semantic refactoring</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#find-and-replace-outside-your-editor\">Find and replace outside your editor, on your local machine</a></p>\n<ul>\n<li><a href=\"#grep-and-sed\"><code class=\"language-text\">grep</code> and <code class=\"language-text\">sed</code></a></li>\n<li><a href=\"#codemod\">Codemod</a></li>\n<li><a href=\"#language-specific-tools\">Language-specific tools</a></li>\n<li><a href=\"#comby\">Comby</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#beyond-your-local-machine\">Making large-scale code changes tractable</a></p>\n<ul>\n<li><a href=\"#campaigns\">Campaigns</a></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Find-and-replace-in-your-editor\" style=\"position:relative;\"><a href=\"#Find-and-replace-in-your-editor\" aria-label=\"Find and replace in your editor permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Find and replace in your editor</h2>\n<p>Most code editors offer some sort of find-and-replace facility. At the most basic level, you have\nliteral string substitution. This enables you to find instances of <code class=\"language-text\">foo</code> and replace them with\n<code class=\"language-text\">bar</code>.</p>\n<p>However, there are many cases where you want to apply a general change pattern, not just replace one\nword with another. Adding arguments to a function, fixing a common anti-pattern, standardizing\nlibrary usage, and transforming data from one format to another—these call for a tool that can\nexpress patterns of transformation.</p>\n<h3 id=\"Regular-expressions\" style=\"position:relative;\"><a href=\"#Regular-expressions\" aria-label=\"Regular expressions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Regular expressions</h3>\n<p>The most commonly used pattern-matching language is Regular Expressions, commonly abbreviated as\n“regex”.<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup> Most code editors support regex searching, and it is commonly toggled on using a button\nor icon with the <code class=\"language-text\">.*</code> symbol.</p>\n<p>With regexes, you can do stuff like this:</p>\n<table>\n<thead>\n<tr>\n<th>Description</th>\n<th>Regex</th>\n<th>Match</th>\n<th>Does not match</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Find all symbol names starting with “foo”</td>\n<td><code class=\"language-text\">foo\\w*</code></td>\n<td>fooBar</td>\n<td>barFoo</td>\n</tr>\n<tr>\n<td>Find all characters between double quotes</td>\n<td><code class=\"language-text\">&quot;[^&quot;]&quot;</code></td>\n<td>“hello world”</td>\n<td>hello world’</td>\n</tr>\n<tr>\n<td>Find all references to fields of a certain variable</td>\n<td><code class=\"language-text\">base\\.\\w+</code></td>\n<td>base.Path</td>\n<td>basePath</td>\n</tr>\n</tbody>\n</table>\n<p>There are different dialects of regex. In this post, we’ll use <a href=\"https://www.gnu.org/software/findutils/manual/html_node/find_html/posix_002dextended-regular-expression-syntax.html#posix_002dextended-regular-expression-syntax\"><strong>POSIX Extended Regular\nExpressions</strong></a>.\nFor those who are unfamiliar with it or who need a quick refresher, here’s an overview of the\nsyntax:</p>\n<ul>\n<li>Alphanumeric characters are generally interpreted literally.</li>\n<li><code class=\"language-text\">*</code> means “zero or more of the preceding character”.</li>\n<li><code class=\"language-text\">+</code> means “one or more of the preceding character”.</li>\n<li><code class=\"language-text\">?</code> means “zero or one of the preceding character”.</li>\n<li>\n<p><code class=\"language-text\">[</code>…<code class=\"language-text\">]</code> matches a single character in a character set. For example <code class=\"language-text\">[ABC]</code> matches either “A”,\n“B”, or “C”. <code class=\"language-text\">[A-Za-z]</code> matches any upper- or lower-case letter. <code class=\"language-text\">[^</code>…<code class=\"language-text\">]</code> matches any character\n<em>not</em> in the set. Many shorthands for character classes also exist:</p>\n<ul>\n<li><code class=\"language-text\">.</code> matches any alphanumeric character. To match a literal period, use <code class=\"language-text\">\\.</code></li>\n<li><code class=\"language-text\">\\w</code> matches any alphanumeric character or underscore. It is equivalent to <code class=\"language-text\">[A-Za-z0-9_]</code>.</li>\n<li><code class=\"language-text\">\\W</code> matches any non-alphanumeric character.</li>\n<li><code class=\"language-text\">\\s</code> matches a single character of whitespace (e.g., spaces or tabs). <code class=\"language-text\">\\S</code> matches any non-whitespace character. <code class=\"language-text\">\\b</code> matches a word boundary.</li>\n</ul>\n</li>\n<li>You can also group parts of your regex with <code class=\"language-text\">(</code>…<code class=\"language-text\">)</code>. These groups are treated as single units,\nso <code class=\"language-text\">(ABC)+</code> will match <code class=\"language-text\">ABC</code>, <code class=\"language-text\">ABCABC</code>, and <code class=\"language-text\">ABCABCABC</code>.</li>\n</ul>\n<p>Regex has a notion of <strong>capturing groups</strong> for find-replace operations. Capturing groups capture\npart of the overall match so they can be referenced in a replacement pattern. For example, here’s a\nregex and replacement pattern that will reverse the order of arguments in a function call:</p>\n<table>\n<thead>\n<tr>\n<th>Input → Output</th>\n<th><code class=\"language-text\">myFunc(foo, bar)</code> → <code class=\"language-text\">myFunc(bar, foo)</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Regex</td>\n<td><code class=\"language-text\">myFunc\\((\\w+), (\\w+)\\)</code></td>\n</tr>\n<tr>\n<td>Replacement pattern</td>\n<td><code class=\"language-text\">myFunc(\\2, \\1)</code><sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup></td>\n</tr>\n</tbody>\n</table>\n<p>In the regex above, the literal parens are escaped <code class=\"language-text\">\\(\\)</code> while the unescaped parens <code class=\"language-text\">()</code> capture\nthe parts of the match that correspond to the arguments to the function.</p>\n<p>One thing to note about regex is the abundance of special characters. All these characters have\nspecial meanings: <code class=\"language-text\">(</code>, <code class=\"language-text\">)</code>, <code class=\"language-text\">[</code>, <code class=\"language-text\">]</code>, <code class=\"language-text\">.</code>, <code class=\"language-text\">$</code>, <code class=\"language-text\">^</code>, <code class=\"language-text\">+</code>, <code class=\"language-text\">?</code>, <code class=\"language-text\">|</code>. This means you’ll need to escape\nthem with <code class=\"language-text\">\\</code> if you want to literally match these characters. This wouldn’t be so bad were it not\nfor the fact that all these characters also occur abundantly in code. This means that your regex\nwill often include many escape sequences. Add grouping into the mix and very soon you’ll end up with\nsomething quite unreadable.</p>\n<p>To alleviate this readability issue, there are a number of regex visualizers you can use to\nunderstand what’s going on:</p>\n<ul>\n<li><a href=\"https://www.debuggex.com/\">Debuggex</a></li>\n<li><a href=\"https://jex.im/regulex\">Regulex</a></li>\n<li><a href=\"https://regexr.com/\">Regexr</a></li>\n<li><a href=\"http://regviz.org/\">Regviz</a></li>\n</ul>\n<p>Even with visualization, however, regexes are often difficult to read and write. It may take\nmultiple attempts and a debugging session to arrive at the correct incantation that properly\nexpresses the find-and-replace pattern you’d like to apply.</p>\n<h2 id=\"Keyboard-macros-and-multiselect\" style=\"position:relative;\"><a href=\"#Keyboard-macros-and-multiselect\" aria-label=\"Keyboard macros and multiselect permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Keyboard macros and multiselect</h2>\n<p>One way to address the readability issues with regexes in your editor is to use keyboard macros,\ninstead.</p>\n<p>Keyboard macros are a feature of some editors (e.g.,\n<a href=\"https://www.gnu.org/software/emacs/manual/html_node/emacs/Keyboard-Macros.html\">Emacs</a>,\n<a href=\"https://hackernoon.com/an-intro-to-vim-macros-f690d8c3c3fd\">Vim</a>,\n<a href=\"https://www.jetbrains.com/help/idea/using-macros-in-the-editor.html\">IntelliJ</a>) that let you record\nkeystrokes and replay them later. If you can describe the change you’d like to make in a set of\nkeystrokes, a keyboard macro can be much easier to execute than a regex find-and-replace.</p>\n<p>Let’s say we want to add an additional parameter to call sites of the function, <code class=\"language-text\">errorutil.Handler</code>\n(<a href=\"https://sourcegraph.com/github.com/sourcegraph/sourcegraph@e6691da7035873fd6394e16cdf32d2f8537fb9e1/-/blob/cmd/frontend/internal/app/errorutil/handlers.go#L19:6\">defined in this\nfile</a>). In\nEmacs, I can describe the change I’d like to make in the following keystrokes:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Ctrl-x (                   # begin recording the macro\nCtrl-s errorutil.Handler(  # search for the pattern\nCtrl-Alt-n Ctrl-b          # jump to one character before the end parens\n, &quot;default&lt;space&gt;value&quot;    # add the default value for the new argument\nCtrl-e                     # move cursor to end of the line\nCtrl-x )                   # finish recording the macro</code></pre></div>\n<p>Once I’ve recorded the macro, I can replay my keystrokes with <code class=\"language-text\">C-x e</code> and can hold down <code class=\"language-text\">e</code> to apply\nit repeatedly.</p>\n<p>Here’s another example involving data transformation. Say you want to turn an HTML table like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;table&gt;\n  &lt;tr&gt;&lt;td&gt;John&lt;/td&gt;&lt;td&gt;25&lt;/td&gt;&lt;tr&gt;\n  &lt;tr&gt;&lt;td&gt;Alice&lt;/td&gt;&lt;td&gt;24&lt;/td&gt;&lt;/tr&gt;\n  ...\n  &lt;tr&gt;&lt;td&gt;Pat&lt;/td&gt;&lt;td&gt;31&lt;/td&gt;&lt;/tr&gt;\n&lt;/table&gt;</code></pre></div>\n<p>into a JSON list like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[\n  { &quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 25 },\n  { &quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 24},\n  ...\n  { &quot;name&quot;: &quot;Pat&quot;, &quot;age&quot;: 31 },\n]</code></pre></div>\n<p>To do that with keyboard macros in Emacs, you can type this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Ctrl-x (                             # begin recording the macro\nCtrl-s &lt; t d Ctrl-f                  # move cursor to &#39;John&#39;\nCtrl-&lt;space&gt; Ctrl-a Ctrl-w           # delete everything on the line prior to &#39;John&#39;\n&quot; Alt-f &quot;                            # put double quotes around &#39;John&#39;\nCtrl-&lt;space&gt; Ctrl-s &lt; t d &gt; Ctrl-w   # delete everything from the end of &quot;John&quot; to &#39;25&#39;\n, &lt;space&gt; &quot; Alt-f &quot; &lt;space&gt; ,        # put quotes around &#39;25&#39; and add a comma\nCtrl-a Ctrl-n                        # move cursor to the beginning of the next line\nCtrl-x )                             # finish recording macro</code></pre></div>\n<p>Here’s what it looks like in real time:</p>\n<img src=\"https://storage.googleapis.com/about.sourcegraph.com/blog/a-programmers-guide-to-find-and-replace/macro.gif\" alt=\"Emacs keyboard macros animation\">\n<p>A related feature of some editors (e.g., <a href=\"https://code.visualstudio.com/docs/getstarted/tips-and-tricks#_multi-cursor-selection\">VS\nCode</a>,\n<a href=\"https://www.sublimetext.com/docs/3/multiple_selection_with_the_keyboard.html\">Sublime Text</a>,\n<a href=\"https://www.vojtechruzicka.com/intellij-idea-tips-tricks-multiple-cursors/\">IntelliJ</a>) is\nmultiselect, which enables the creation of multiple cursors or selections. Here’s a short clip of\nusing multiselect in VS Code tackling the same HTML-to-JSON transformation:</p>\n<img src=\"https://storage.googleapis.com/about.sourcegraph.com/blog/a-programmers-guide-to-find-and-replace/multiselect.gif\" alt=\"VS Code multiselect\">\n<p>You can do some <a href=\"https://twitter.com/JoshuaKGoldberg/status/1259159590425542657\">pretty cool stuff</a> with\nmultiselect.</p>\n<p>Both keyboard macros and multiselect are powerful, but they are only supported in some editors. They\nalso work best when the change is relatively simple and is limited to a few files that can be opened\nin the editor.</p>\n<h3 id=\"Semantic-refactoring\" style=\"position:relative;\"><a href=\"#Semantic-refactoring\" aria-label=\"Semantic refactoring permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Semantic refactoring</h3>\n<p>Many editors and editor plugins support refactoring code using knowledge of the language\nsemantics. These refactoring capabilities are built using compiler libraries and so achieve a 100%\ndegree of accuracy and precision. The IntelliJ family of IDEs supports semantic refactoring for most\nof their supported languages. The <a href=\"https://github.com/Microsoft/language-server-protocol\">Language Server\nProtocol</a> aims to enable <a href=\"https://langserver.org/\">an ecosystem of\nlanguage servers</a> that can provide semantic capabilities across many\neditors and languages.</p>\n<p>You should consult your editor documentation or plugin ecosystem to see if semantic refactoring is\nsupported for your language. Semantic refactoring sometimes goes by different names like\n“intellisense”, “code intelligence”, or “structural search and replace”.</p>\n<p>The downside to semantic refactoring is that it is very specific to the language. A separate\nintegration for each language must be created, which means that frequently the language you’re\nworking in may be unsupported in your editor of choice. This is especially true if the language is\nsomething like HTML, Shell, or any of the innumerable YAML, JSON, or XML schemas.</p>\n<p>Even if the language is supported, the transformations must be described in terms of modifications\nto the parsed AST. Making arbitrary modifications to the AST requires writing code, which involves a\nsignificant time investment. Consequently, semantic refactoring tools often provide out-of-the-box\ntransformations that cover the most common types of refactorings, such as renaming a function or\nadding an additional parameter. If your transformation fits into one of these ready-made templates,\nyou have an extremely accurate and powerful tool to make broad changes across all the files in your\neditor workspace. If your transformation does not fall into one of these templates, then you’re out\nof luck.</p>\n<h2 id=\"Find-and-replace-outside-your-editor\" style=\"position:relative;\"><a href=\"#Find-and-replace-outside-your-editor\" aria-label=\"Find and replace outside your editor permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Find and replace outside your editor</h2>\n<p>Thus far, we’ve focused on find-and-replace inside the editor. These features can be very powerful,\nbut they are constrained by what you are able to edit in your editor. There are a number of reasons\nwhy you’ll have to make code modifications outside your editor:</p>\n<ul>\n<li>Your editor doesn’t make it easy to apply the type of transformation you want.</li>\n<li>You might be modifying files in a place where your editor isn’t available (e.g., a server).</li>\n<li>You might be applying a change across more files than you want to open in your editor.</li>\n<li>You might want to apply a large-scale change across code that doesn’t exist on your local machine.</li>\n</ul>\n<p>As a general rule, the larger the universe of code you care about is (whether that universe is a\nlarge proprietary codebase or the universe of open source), the more likely it is that you’ll need\nto find and replace outside your editor. To do that, we’ll need to add some more tools to our\ntoolbox.</p>\n<h3 id=\"grep-and-sed\" style=\"position:relative;\"><a href=\"#grep-and-sed\" aria-label=\"grep and sed permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>grep and sed</h3>\n<p><code class=\"language-text\">grep</code><sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup> is a program that scans text files line-by-line and prints each line that matches a\nregular expression. <code class=\"language-text\">sed</code><sup id=\"fnref-4\"><a href=\"#fn-4\" class=\"footnote-ref\">4</a></sup> is a tool that matches and transforms text using regular\nexpressions. Both are extremely versatile and useful tools to have in your programmer’s toolbox.</p>\n<p>Suppose again you’re adding an additional parameter to the <code class=\"language-text\">errorutil.Handler</code> <a href=\"https://sourcegraph.com/github.com/sourcegraph/sourcegraph@11fe76d8682e32957e7dadcecd6ef4ce364c39d0/-/blob/cmd/frontend/internal/app/errorutil/handlers.go#L19\">function</a>\nand now need to update all call sites of that function to pass some default value for the extra\nargument. You can do that<sup id=\"fnref-5\"><a href=\"#fn-5\" class=\"footnote-ref\">5</a></sup> in a one-liner with <code class=\"language-text\">grep</code> and <code class=\"language-text\">sed</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">grep -lRE &#39;errorutil\\.Handler&#39; | xargs sed -i -E &#39;s/Handler\\(([A-Za-z0-9_\\.]+)\\)/Handler(\\1, &quot;default value&quot;)/&#39;</code></pre></div>\n<p>It fits on one line! But it’s not the clearest thing in the world, so let’s break it down<sup id=\"fnref-6\"><a href=\"#fn-6\" class=\"footnote-ref\">6</a></sup>:</p>\n<table>\n<thead>\n<tr>\n<th>Part</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">grep</code></td>\n<td>We’re using <code class=\"language-text\">grep</code> to generate a list of filenames that may contain the specified pattern. We’ll then feed these to <code class=\"language-text\">sed</code> to do the actual replacing. This is necessary for performance reasons, as running <code class=\"language-text\">sed</code> over all the files in your repository will be slow.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">-lRE</code></td>\n<td>The <code class=\"language-text\">-l</code> flag tells <code class=\"language-text\">grep</code> to print only filenames. The <code class=\"language-text\">-R</code> flag tells <code class=\"language-text\">grep</code> to do a recursive search in the current directory. The <code class=\"language-text\">-E</code> flag tells grep to use the extended regex syntax, which we use throughout this post.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">&#39;errorutil\\.Handler&#39;</code></td>\n<td>This is the regex pattern that selects for matches like <code class=\"language-text\">errorutil.Handler(serveRepoBadge)</code>. Note that this regex doesn’t have to match the expression we want to replace exactly, because the purpose here is only to filter down to a small enough set of filenames to pass to <code class=\"language-text\">sed</code>.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">|</code></td>\n<td>This is a Unix pipe, which forwards the standard output of the previous command to the standard input of the following command.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">xargs</code></td>\n<td>This is a program that wraps other commands to map standard input to command line arguments. <code class=\"language-text\">sed</code> takes filenames as command line arguments, and this is necessary to map the output of <code class=\"language-text\">grep</code> to command line arguments to <code class=\"language-text\">sed</code>.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">sed</code></td>\n<td><code class=\"language-text\">sed</code> transforms the contents of a file using a regex replacement pattern.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">-i</code></td>\n<td>This flag tells <code class=\"language-text\">sed</code> to modify files “in place”, rather than printing the transformed contents to standard output.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">-E</code></td>\n<td>This flag tells <code class=\"language-text\">sed</code> to used extended regex syntax.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">s</code><br><code class=\"language-text\">/</code><br><code class=\"language-text\">Handler\\(([A-Za-z0-9_\\.]+)\\)</code><br><code class=\"language-text\">/</code><br><code class=\"language-text\">Handler(\\1, &quot;default value&quot;)</code><br><code class=\"language-text\">/</code></td>\n<td>This specifies the replacement pattern and is a bit of a doozy, so let’s break it down even further. This is actually an expression in the <code class=\"language-text\">sed</code> language. <code class=\"language-text\">s</code> is the “substitute” command. The character immediately after <code class=\"language-text\">s</code> specifies the delimiter that will separate arguments to <code class=\"language-text\">s</code>. (In this case, it is <code class=\"language-text\">/</code>, but we can make it any character we want so long as we’re consistent.) The first argument, <code class=\"language-text\">Handler\\(([A-Za-z0-9_\\.]+)\\)</code>, is a regular expression with a matching group to capture the argument to the function call. The second argument, <code class=\"language-text\">Handler(\\1, &quot;default value&quot;)</code>, is a replacement pattern, which references the regex capture group with <code class=\"language-text\">\\1</code>.</td>\n</tr>\n</tbody>\n</table>\n<p>If all this is clear as mud, don’t worry—you’re not alone. <code class=\"language-text\">grep</code> and <code class=\"language-text\">sed</code> are powerful tools, but\nthey’re not super beginner-friendly.<sup id=\"fnref-7\"><a href=\"#fn-7\" class=\"footnote-ref\">7</a></sup> <sup id=\"fnref-8\"><a href=\"#fn-8\" class=\"footnote-ref\">8</a></sup></p>\n<p><a href=\"https://github.com/BurntSushi/ripgrep\">ripgrep (<code class=\"language-text\">rg</code>)</a> is a newer alternative to <code class=\"language-text\">grep</code><sup id=\"fnref-9\"><a href=\"#fn-9\" class=\"footnote-ref\">9</a></sup> that is\nfaster and has more user-friendly defaults (e.g., you don’t need to remember to set flags like\n<code class=\"language-text\">-RE</code> to get the behavior you want). Here’s the one-liner above rewritten with ripgrep, instead of\ngrep:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">rg -l &#39;errorutil\\.Handler&#39; | xargs sed -i -E &#39;s/Handler\\(([A-Za-z0-9_\\.]+)\\)/Handler(\\1, &quot;default value&quot;)/&#39;</code></pre></div>\n<p>This is better, but still a little gnarly. A good part of the reason that <code class=\"language-text\">grep</code> and <code class=\"language-text\">sed</code> are\nconsidered hard is because regexes are hard.</p>\n<h2 id=\"Codemod\" style=\"position:relative;\"><a href=\"#Codemod\" aria-label=\"Codemod permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Codemod</h2>\n<p>One way to alleviate the pain of finding and replacing with regular expressions is to do it\ninteractively. This is the approach taken by <a href=\"https://github.com/facebook/codemod\">Codemod</a>.</p>\n<p>Here’s how you would use <code class=\"language-text\">codemod</code> to add an additional argument to <code class=\"language-text\">errorutil.Handler</code> call sites:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">codemod -m -d . --extensions go &#39;errorutil.Handler\\(([A-Za-z0-9_\\.]+)\\)&#39; &#39;errorutil.Handler(\\1, &quot;default value&quot;)&#39;</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>Part</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">codemod</code></td>\n<td>The Codemod command.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">-m</code></td>\n<td>Turns on multiline matching. This is nice, as getting <code class=\"language-text\">sed</code> to match over multiple lines is a bit of a pain.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">-d .</code></td>\n<td>Search recursively in the current directory.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">--extensions go</code></td>\n<td>Restrict search to files ending in <code class=\"language-text\">.go</code>.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">errorutil.Handler\\(([A-Za-z0-9_\\.]+)\\)</code></td>\n<td>The “find” regex, with a capturing group.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">errorutil.Handler(\\1, &quot;default value&quot;)</code></td>\n<td>The replace pattern.</td>\n</tr>\n</tbody>\n</table>\n<p>When you run the command, <code class=\"language-text\">codemod</code> will prompt you to accept, reject, or make further edits to each\nchange:</p>\n<img src=\"https://storage.googleapis.com/about.sourcegraph.com/blog/a-programmers-guide-to-find-and-replace/codemod.png\" alt=\"Codemod interactive interface\">\n<p>This interactivity is nice, because it’s very difficult to write regexes that work 100% correctly on\nthe first try. If you decide you need to refine the regex, you can exit and <code class=\"language-text\">codemod</code> will remember\nyour place, so you can pick up where you left off. You also have the option of manually editing a\ngiven match, which is useful for the handling edge cases where your regex replacement pattern does\nthe wrong thing.</p>\n<p>Codemod also has a Python API for expressing interactive transformations in Python code, which is\nuseful for describing more complex changes:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> codemod\ncodemod<span class=\"token punctuation\">.</span>Query<span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>run_interactive<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h2 id=\"Language-specific-tools\" style=\"position:relative;\"><a href=\"#Language-specific-tools\" aria-label=\"Language specific tools permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Language-specific tools</h2>\n<p>Just as certain editors and editor plugins have support for semantic refactoring, there are\ncommand-line tools and libraries that support modifying code by transforming the\n<a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\">AST</a>.</p>\n<p>In the JavaScript world, two popular tools are\n<a href=\"https://github.com/facebook/jscodeshift\">jscodeshift</a> and\n<a href=\"https://github.com/benjamn/recast\">recast</a>. Similar tools exist for other languages.</p>\n<p>These are fantastic if your change is complex enough to require the full expressivity and type\nsafety of editing the AST.</p>\n<p>The downsides are:</p>\n<ul>\n<li>You have to learn a new tool for each language.</li>\n<li>A tool might not yet exist for your language, or it may lack certain features.</li>\n<li>Because you’re describing your changes in terms of transformations of the AST, you will probably\nhave to write code and learn the structure of the language’s AST.</li>\n<li>Your transformation will have a hard time touching textual parts of the source code that are not\nrepresented in the AST. For example, the contents of string literals or comments.</li>\n</ul>\n<h2 id=\"Comby\" style=\"position:relative;\"><a href=\"#Comby\" aria-label=\"Comby permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Comby</h2>\n<p>Another way to alleviate the pain of regular expressions that doesn’t require diving off the\ndeep-end into language-specific semantic analysis is to use a textual pattern matching language\nthat’s more suited to code.</p>\n<p><a href=\"https://comby.dev/\">Comby</a> is a fairly new tool that introduces a simple new syntax for matching\ncommon patterns in code. It aims to be both more expressive and more user-friendly than regex in\nthis domain.<sup id=\"fnref-10\"><a href=\"#fn-10\" class=\"footnote-ref\">10</a></sup></p>\n<p>Here is a Comby one-liner that handles adding an extra argument to <code class=\"language-text\">errorutil.Handler</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">rg -l errorutil | xargs comby -in-place &#39;errorutil.Handler(:[1])&#39; &#39;errorutil.Handler(:[1], &quot;default value&quot;)&#39;</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>Part</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">rg -l errorutil</code></td>\n<td>Use ripgrep to print names of all code files that contain “errorutil”</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">| xargs</code></td>\n<td>Pipe the filenames to <code class=\"language-text\">comby</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">comby -in-place</code></td>\n<td>Edit the files in-place with the <code class=\"language-text\">comby</code> CLI</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">errorutil.Handler(:[1])</code></td>\n<td>The match pattern, which sub-matches the argument using the Comby <a href=\"https://comby.dev/#basic-usage\">hole syntax</a></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">errorutil.Handler(:[1], &quot;default value&quot;)</code></td>\n<td>The replace pattern, which references the sub-matched hole</td>\n</tr>\n</tbody>\n</table>\n<p>Contrast the relative readability of this <code class=\"language-text\">comby</code> example with the regex we wrote for <code class=\"language-text\">sed</code> earlier\nin this post.</p>\n<p>Comby can also express patterns that cannot be expressed in any regex. Consider the following call\nsite:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">errorutil.Handler(someOtherFunction(blah))</code></pre></div>\n<p>This call site would not be selected by our earlier regular expression, which doesn’t account for\nthe nested parens. We could update the regex to account for one layer of nested parens:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">errorutil\\.Handler\\((\\w*\\(\\w*\\)|\\w+)\\)</code></pre></div>\n<p>But what if we had double-nested parens, or triple-nested parens? These are perfectly valid in the\ncode, but to accomodate them, we’d have to make our regex longer and longer—and no matter how long\nwe made it, we still couldn’t full capture what we’re trying to describe.</p>\n<p>This difficulty points to a more general limitation of regular expressions: they cannot express\nnestable “bookend” patterns of the form <code class=\"language-text\">&lt;delimiter&gt;stuff&lt;delimiter&gt;</code>. Such patterns are everywhere\nin code: string constants (<code class=\"language-text\">&quot;foo&quot;</code>), function calls (<code class=\"language-text\">foo(bar())</code>), control blocks (<code class=\"language-text\">if () {}</code>),\narray literals (<code class=\"language-text\">[]</code>), and more. Regular expressions cannot express these patterns, but Comby makes\nit easy.</p>\n<p>Here are a few more examples:</p>\n<table>\n<thead>\n<tr>\n<th>Description</th>\n<th>Comby invocation</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Reverse function argument order</td>\n<td><code class=\"language-text\">comby &#39;myFunc(:[1], :[2])&#39; &#39;myFunc(:[2], :[1])&#39;</code></td>\n</tr>\n<tr>\n<td>Convert HTML table to JSON</td>\n<td><code class=\"language-text\">comby &#39;&lt;tr&gt;&lt;td&gt;:[1]&lt;/td&gt;&lt;td&gt;:[2]&lt;/td&gt;&lt;/tr&gt;&#39; &#39;&quot;:[1]&quot;: :[2]&#39;</code></td>\n</tr>\n<tr>\n<td>Update Go error handling to use wrapped errors</td>\n<td><code class=\"language-text\">comby &#39;fmt.Errorf(&quot;:[head]%s:[tail]&quot;, err)&#39; &#39;fmt.Errorf(&quot;:[head]%w:[tail]&quot;, err)&#39;</code></td>\n</tr>\n</tbody>\n</table>\n<p>Comby’s advantages can be summed up in two words: expressivity and ergonomics.</p>\n<ul>\n<li>Expressivity: You can capture patterns that involve nested delimiters, which are inexpressible with regex.</li>\n<li>Ergonomics: Unlike regex, Comby has very few special characters, so Comby patterns are generally\nmore readable and writable.</li>\n</ul>\n<p>Comby also supports an interactive mode (using the <code class=\"language-text\">--review</code> flag) like Codemod, and you can play\naround with it in a live demo at <a href=\"https://comby.live/\">comby.live</a>.</p>\n<p>Due to its newness, Comby is not yet as widely adopted as regex-based tools like <code class=\"language-text\">grep</code> and <code class=\"language-text\">sed</code>,\nbut it is off to a strong start and I predict it will supplant regex in more and more use cases in\nthe coming years.</p>\n<h2 id=\"Beyond-your-local-machine\" style=\"position:relative;\"><a href=\"#Beyond-your-local-machine\" aria-label=\"Beyond your local machine permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Beyond your local machine</h2>\n<p>Find-and-replace over files on your local machine is one thing, but there are situations where\nyou’ll need to apply a transformation across a universe of code that exists beyond your local files.</p>\n<p>If you’re working in a company, this might be something like adopting a consistent logging standard\nacross all services in your application. If you’re working in open source, this might be updating\nall the callers of a deprecated library function that has hundreds of downstream dependencies. In\neither case, the trivial becomes intractable at a large enough scale.</p>\n<p>This problem is widespread, especially across large software organizations, and will only increase\nin severity in the coming years as the interdependent universe of code continues to expand.</p>\n<p><a href=\"https://twitter.com/fatih/status/1259912881186824192\">Google calls it LSC (Large-Scale Changes) and devotes an entire chapter to\nit</a> in the “flamingo book”, <a href=\"https://www.oreilly.com/library/view/software-engineering-at/9781492082781/\"><em>Software\nEngineering at\nGoogle</em></a>. Various other\nnames we’ve heard include “large-scale refactoring”, “large-scale codemods”, “code shepherding”, and\n“code change campaigns”. Here we call them, simply, “campaigns”.</p>\n<p>The anecdotes are startling. Inside some organizations, even small campaigns can take months or even\nyears to execute. Google has invested millions of dollars to create the internal dev infrastructure\nto enable campaigns to be completed tractably.  Many other development organizations have created\ntools in the same vein, but they typically cannot afford to invest as much into these tools as\nGoogle can. These tools are usually specific to the organization that created them and rarely\nreleased publicly.</p>\n<h3 id=\"Campaigns\" style=\"position:relative;\"><a href=\"#Campaigns\" aria-label=\"Campaigns permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Campaigns</h3>\n<p><em><strong>Note:</strong> Campaigns have evolved since this post was written, and we now call them batch changes. See [our docs](<a href=\"https://docs.sourcegraph.com/batch\">https://docs.sourcegraph.com/batch</a></em>changes) for the latest._</p>\n<p>After hearing the same thing over and over again from different development teams, we decided to try\nto build a general solution for this hairy problem of large-scale code transformation. Starting in\nSourcegraph 3.15, you can initiate and execute campaigns in Sourcegraph. Here’s an example:</p>\n<p>Suppose your organization has decided it wants to standardize error handling across your\ncodebase. In particular, you want to use <a href=\"https://blog.golang.org/go1.13-errors\">wrapped errors</a> in\nGo code. This means you want to ensure that instances of <code class=\"language-text\">fmt.Errorf</code> use the <code class=\"language-text\">%w</code> format verb,\nrather than <code class=\"language-text\">%s</code>.</p>\n<p>Without a campaign shepherding tool, this would involve cloning down all your repositories\none-by-one, running a find-replace script locally, manually pushing up a branch, and opening a pull\nrequest for each repository affected by the change. That’s a lot of tedious repetition that can\noccupy multiple days of your time.</p>\n<p>Here’s how you’d do that in a campaign:</p>\n<ol>\n<li>\n<p>Create a JSON file named <code class=\"language-text\">wrapped-errors.action.json</code> with the following contents:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n &quot;scopeQuery&quot;: &quot;repo:^github.com/sourcegraph/ fmt.Errorf&quot;,\n &quot;steps&quot;: [\n   {\n     &quot;type&quot;: &quot;docker&quot;,\n     &quot;image&quot;: &quot;comby/comby&quot;,\n     &quot;args&quot;: [\n       &quot;-in-place&quot;,\n       &quot;fmt.Errorf(\\&quot;:[head]%s:[tail]\\&quot;, err)&quot;,\n       &quot;fmt.Errorf(\\&quot;:[head]%w:[tail]\\&quot;, err)&quot;,\n       &quot;-matcher&quot;,\n       &quot;.go&quot;,\n       &quot;-d&quot;,\n       &quot;/work&quot;\n     ]\n   }\n ]\n}</code></pre></div>\n<p>The <code class=\"language-text\">scopeQuery</code> field selects the set of repositories to run the change over. The <code class=\"language-text\">steps</code> field\nspecifies a sequence of commands or Docker containers to run over each repository. In this case,\nwe are using the Comby Docker container to find all instances of <code class=\"language-text\">fmt.Errorf</code> that end in <code class=\"language-text\">,\nerr)</code> and have <code class=\"language-text\">%s</code> in the format string, and replace the <code class=\"language-text\">%s</code> with <code class=\"language-text\">%w</code>.</p>\n</li>\n<li>Using the <a href=\"https://github.com/sourcegraph/src-cli/#installation\"><code class=\"language-text\">src</code></a> CLI, run <code class=\"language-text\">src actions\nexec -f wrapped-errors.action.json -create-patchset</code>. This will clone down each repository to a\nsandbox, apply the transformation, and upload the patchset to Sourcegraph. It will also print a\nlink you can click to turn the patchset into a campaign.</li>\n<li>\n<p>After clicking the link to create a campaign, enter in the title and description of your\ncampaign. Click <code class=\"language-text\">Create draft</code>.</p>\n<img src=\"https://storage.googleapis.com/about.sourcegraph.com/blog/a-programmers-guide-to-find-and-replace/new-campaign.png\" alt=\"Create a new campaign\">\n</li>\n<li>\n<p>Examine each pull request and click <code class=\"language-text\">Publish</code> after you’ve verified this proposes the desired\nchange in each repository.</p>\n<img src=\"https://storage.googleapis.com/about.sourcegraph.com/blog/a-programmers-guide-to-find-and-replace/campaign-publish.gif\" alt=\"Publishing a campaign\">\n</li>\n<li>From Sourcegraph, you have a single dashboard where you can monitor the progress of all pull\nrequests in this campaign.</li>\n</ol>\n<p>In the example above, we used Comby, because that was the simplest thing to use, but campaigns\nsupport any find-replace tool that can be run as a local command or Docker container. Comby,\nCodemod, <code class=\"language-text\">grep</code>, <code class=\"language-text\">sed</code>, and any custom script are all fair game.</p>\n<p>Campaigns are currently in beta, available in Sourcegraph versions 3.15 and later. Read the\n<a href=\"https://docs.sourcegraph.com/campaigns\">Campaigns documentation</a> to learn more.</p>\n<h2 id=\"Further-reading\" style=\"position:relative;\"><a href=\"#Further-reading\" aria-label=\"Further reading permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Further reading</h2>\n<p>If you’re interested in learning more about the tools covered in this post, here are some useful\nresources:</p>\n<ul>\n<li>\n<p>Regular expressions</p>\n<ul>\n<li><a href=\"https://regexone.com/\">RegexOne</a>, an interactive tutorial</li>\n<li><a href=\"https://www.digitalocean.com/community/tutorials/an-introduction-to-regular-expressions\">An Introduction To Regular Expressions</a> from Digital Ocean</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">grep</code></p>\n<ul>\n<li><a href=\"https://ryanstutorials.net/linuxtutorial/cheatsheetgrep.php\">Grep cheatsheet - Ryans Tutorials</a></li>\n<li><a href=\"https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_04_02.html\">Grep guide from TLDP</a></li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">sed</code></p>\n<ul>\n<li><a href=\"https://www.digitalocean.com/community/tutorials/the-basics-of-using-the-sed-stream-editor-to-manipulate-text-in-linux\">Guide to sed basics</a> from Digital Ocean</li>\n<li><a href=\"https://www.grymoire.com/Unix/Sed.html\">Sed - An introduction and Tutorial by Bruce Barnett</a></li>\n</ul>\n</li>\n<li>\n<p>Keyboard macros and multiselect</p>\n<ul>\n<li><a href=\"https://www.gnu.org/software/emacs/manual/html_node/emacs/Basic-Keyboard-Macro.html#Basic-Keyboard-Macro\">GNU guide to Emacs keyboard macros</a></li>\n<li><a href=\"https://hackernoon.com/an-intro-to-vim-macros-f690d8c3c3fd\">An intro to Vim Macros</a></li>\n<li><a href=\"https://code.visualstudio.com/docs/editor/codebasics#_multiple-selections-multicursor\">Multi-cursor and multiple selections in VS Code</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/facebook/codemod\">Codemod</a></li>\n<li>\n<p>Comby</p>\n<ul>\n<li><a href=\"https://comby.dev/\">Comby documentation and reference site</a></li>\n<li><a href=\"https://comby.live/\">Comby interactive playground</a></li>\n</ul>\n</li>\n<li>\n<p>Campaigns</p>\n<ul>\n<li><a href=\"https://docs.sourcegraph.com/campaigns\">Campaigns Documentation and Getting Started</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=aqcCrqRB17w\">A video introduction to campaigns</a></li>\n</ul>\n</li>\n</ul>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p>I say “most commonly used”, but fluency with regex is by no means ubiquitous. You can graduate\nfrom a four-year computer science program without writing a single regex. I knew one engineer\nwho had more than a decade of experience and was a contributor to several prominent open-source\nprojects, but viewed regex as a foreign language.</p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-2\">\n<p><code class=\"language-text\">$1</code> is sometimes used rather than <code class=\"language-text\">\\1</code> in the replacement syntax. Check the documentation to\ndetermine which is supported in your editor.</p>\n<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-3\">\n<p>“grep” stands for “global regular expression print”.</p>\n<a href=\"#fnref-3\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-4\">\n<p>“sed” stands for “stream editor”</p>\n<a href=\"#fnref-4\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-5\">\n<p>There are cases where this regex won’t work. For example, <code class=\"language-text\">errorutil.Handler(foo(bar))</code> or\n<code class=\"language-text\">errorutil.Handler(foo(bar(baz)))</code>. In general, any pattern that requires handling nested\ndelimiters cannot be fully expressed in regex. Practically speaking, this isn’t a dealbreaker,\nbecause you can often come up with a regex where the edge cases it doesn’t handle properly don’t\nexist in the code you’re modifying. However, coming up with such a regex can be quite\nannoying. If you’re interested in learning about a pattern language that eliminates this\nexpressivity problem, jump to the section on Comby.</p>\n<a href=\"#fnref-5\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-6\">\n<p>If you’re fairly inexperienced with the Unix command line, <a href=\"https://explainshell.com/explain?cmd=grep+-lRE+%27errorutil%5C.Handler%27+%7C+xargs+sed+-i+-E+%27s%2FHandler%5C%28%28%5BA-Za-z0-9_%5C.%5D%2B%29%5C%29%2FHandler%28%5C1%2C+%22default+value%22%29%2F%27\">you can try viewing the one-liner\non\nexplainshell.com</a>.</p>\n<a href=\"#fnref-6\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-7\">\n<p>Another complicating factor is that there are multiple implementations of <code class=\"language-text\">grep</code> and <code class=\"language-text\">sed</code>\nthat have slightly different behavior and are defaults on different systems. macOS by default\nuses the BSD variants of <code class=\"language-text\">grep</code> and <code class=\"language-text\">sed</code> while Linux uses the GNU variants. The GNU and BSD\nvariants don’t support the same sets of flags and positional arguments, so <code class=\"language-text\">grep</code> and <code class=\"language-text\">sed</code>\ninvocations that work on Linux often break on macOS or vice versa. You can get around this by\ninstalling the non-default variant on either system, but this, of course, adds complexity.</p>\n<a href=\"#fnref-7\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-8\">\n<p>Two other Unix commands that are often used in conjunction with <code class=\"language-text\">grep</code> and <code class=\"language-text\">sed</code> are <code class=\"language-text\">find</code>\nand <code class=\"language-text\">awk</code>. For brevity’s sake, we don’t go into them here.</p>\n<a href=\"#fnref-8\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-9\">\n<p>Other <code class=\"language-text\">grep</code> alternatives include <a href=\"https://github.com/beyondgrep/ack3/\"><code class=\"language-text\">ack</code></a>,\n<a href=\"https://github.com/ggreer/the_silver_searcher\"><code class=\"language-text\">ag</code></a>, and\n<a href=\"https://github.com/sampson-chen/sack\"><code class=\"language-text\">sack</code></a>. <code class=\"language-text\">git-grep</code> is <code class=\"language-text\">grep</code> but only over files known\nto <code class=\"language-text\">git</code> (and for this reason, it’s often much faster). Personally, I’ve found ripgrep to be the\nfastest grep alternative, generally speaking.</p>\n<a href=\"#fnref-9\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-10\">\n<p>It just so happens that Comby was created by a fellow Sourcegrapher, the brilliant <a href=\"https://rijnard.com/\">Rijnard\nvan Tonder</a>, as part of his Ph.D. research. Part of the reason he joined\nSourcegraph was to put his research into practice among as many developers as possible. If you\nalso have a fantastic new idea that can improve the productivity of many developers, shoot me a\nmessage at <a href=\"mailto:beyang@sourcegraph.com\">beyang@sourcegraph.com</a>!</p>\n<a href=\"#fnref-10\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>"}