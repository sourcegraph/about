{"expireTime":9007200905229171000,"key":"transformer-remark-markdown-html-afc56be51cd46ea47ae4d286f4c1dd1e-gatsby-remark-autolink-headersgatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-unwrap-imagesgatsby-remark-imagesgatsby-remark-smartypants-","val":"<img src=\"/blog/optimizing-code-intelligence-commit-graph.png\" alt=\"Optimizing code intelligence commit graph graphic\">\n<p>In <a href=\"/blog/optimizing-a-code-intel-commit-graph/\">Part 1 of this optimization story</a>, we detailed how Sourcegraph can resolve code intelligence queries using data from older commits when data on the requested commit is not yet available. The implementation lies completely within PostgreSQL, and the queries run with very low latency (&#x3C;1ms). We boldly claimed that our fears of scalability were no longer cause for concern.</p>\n<p>Turns out that claim was a half-truth (if not a lie) as Sourcegraph solves the problem well, but only at a particular scale. There is an entire class of enterprise customers who could benefit from this feature as well, but the speed at which the code moves is a huge obstacle to overcome when calculating visible uploads on demand.</p>\n<p>Because our implementation relies on a graph traversal within PostgreSQL triggered frequently by user action, we need to limit the distance each query can travel in the commit graph. This is to guarantee that single requests are not taking a disproportionate amount of application or database memory and causing issues for other users. The introduction of this limit brings stability to the Sourcegraph instance by capping the maximum load a single query can put on the database. But there is a downside: there are many shapes of commit graphs that will fail to find a visible upload traversing a limited commit graph, even if the distance is not too large.</p>\n<p>In <a href=\"/blog/optimizing-a-code-intel-commit-graph/#Performance-improvements\">Part 1</a>, we stopped tracking the distance between commits as a performance optimization. Because of this, we no longer have a way to limit by commit <em>distance</em>. Instead, we enforce a limit on the number of total commits seen during the traversal. This means that one query will travel a smaller distance on a commit graph with a large number of merge commits, and a larger distance on a commit graph that is mostly linear.</p>\n<p>The following Git commit graph illustrates this difference. Searching from commit <code class=\"language-text\">g</code>, we could find index data on commits <code class=\"language-text\">a</code> and <code class=\"language-text\">m</code>, both only two steps away. However, if we had a limit of 10, we would see only the commits directly adjacent to <code class=\"language-text\">g</code> and would hit our limit before expanding outwards.</p>\n<figure>\n  <img src=\"https://sourcegraphstatic.com/blog/commit-graph-optimizations/graph6.png\" alt=\"High-merge commit graph\" class=\"no-shadow\">\n  <figcaption>A Git commit graph with a large number of paths from <code>a</code> to <code>g</code> and <code>g</code> to <code>m</code>.</figcaption>\n</figure>\n<p>Another issue is high commit velocity. Suppose that we have a hard limit of viewing 50 commits. We will then be able to look (approximately) 25 commits in a single direction. If the process for uploading LSIF data only happens every 50 commits, on average, then there will be pockets of commits that cannot see far enough to spot a relative commit with an upload. This turns out to be common in the case of large development teams working on a single repository.</p>\n<p>The following Git commit graph illustrates this, where commit <code class=\"language-text\">b</code> could simply be stranded on both sides by ancestor and descendant commits with code intelligence data just out of reach.</p>\n<figure>\n  <img src=\"https://sourcegraphstatic.com/blog/commit-graph-optimizations/graph7.png\" alt=\"Flat commit graph\" class=\"no-shadow\">\n  <figcaption>A Git commit graph with large distances between code intelligence indexes.</figcaption>\n</figure>\n<h2 id=\"A-better-design\" style=\"position:relative;\"><a href=\"#A-better-design\" aria-label=\"A better design permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>A better design</h2>\n<p>In these circumstances, bounded traversals are a fundamental design flaw. To get rid of this constraint, we turn to a technique that was very successful in the past: index the result of the queries out of band. This technique forms the basis of our search: we create a series of n-gram indexes over source text so we can quickly look inside text documents. This technique also forms the basis of our code intelligence: we create <a href=\"https://microsoft.github.io/language-server-protocol/specifications/lsif/0.5.0/specification\">indexes</a> that contain the answers to all the relevant language server queries that could be made about code at a particular revision.</p>\n<p>In the same spirit, we eschew graph traversal at query time and calculate the set of visible uploads for each commit ahead of time (whenever the commit graph or set of uploads for a repository changes). This reduces the complexity of the query in the request path into a simple single-record lookup.</p>\n<p>This <a href=\"https://github.com/sourcegraph/sourcegraph/issues/12098\">change</a> was made in our 3.20 release and introduced 2 new tables: <code class=\"language-text\">lsif_nearest_uploads</code> and <code class=\"language-text\">lsif_dirty_repositories</code>.</p>\n<p>The <code class=\"language-text\">lsif_nearest_uploads</code> table stores what you would expect. For each commit that has a visible upload, there is a row in the table indicating the source commit, the identifier of the visible upload, and the distance between the source commit and the commit on which the upload is defined. Multiple uploads may be visible from a single commit as we look in both ancestor and descendant directions. There may also be multiple visible uploads in the case of different languages or different directories at index time, but we‚Äôll hand-wave around these particular details for now.</p>\n<table>\n<thead>\n<tr>\n<th>repository</th>\n<th>commit</th>\n<th>upload_id</th>\n<th>distance</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>github.com/sourcegraph/sample</td>\n<td><code>323e23</code></td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>github.com/sourcegraph/sample</td>\n<td><code>d67b8d</code></td>\n<td>1</td>\n<td>0</td>\n</tr>\n<tr>\n<td>github.com/sourcegraph/sample</td>\n<td><code>4c8d9d</code></td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>github.com/sourcegraph/sample</td>\n<td><code>4c8d9d</code></td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>github.com/sourcegraph/sample</td>\n<td><code>f4fb06</code></td>\n<td>2</td>\n<td>0</td>\n</tr>\n<tr>\n<td>github.com/sourcegraph/sample</td>\n<td><code>a36064</code></td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>github.com/sourcegraph/sample</td>\n<td><code>313082</code></td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>github.com/sourcegraph/sample</td>\n<td><code>6a06fc</code></td>\n<td>1</td>\n<td>3</td>\n</tr>\n</tbody>\n</table>\n<p>The <code class=\"language-text\">lsif_dirty_repositories</code> table tracks which repositories need their commit graphs updated. When we receive an upload for a repository, or get a request for a commit that we don‚Äôt currently track, we bump the <code class=\"language-text\">dirty_token</code> value attached to that repository. When we are about to refresh the graph, we note the dirty token, calculate the set of visible uploads for each commit, write it to the database, and set the <code class=\"language-text\">update_token</code> to the value of the dirty token we noted earlier. This ensures that we avoid a particular class of race conditions that occur when we receive an upload at the same time we‚Äôre re-calculating the commit graph from a previous upload.</p>\n<table>\n<thead>\n<tr>\n<th>repository</th>\n<th>dirty_token</th>\n<th>update_token</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>github.com/sourcegraph/sample</td>\n<td>42</td>\n<td>42</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"Example\" style=\"position:relative;\"><a href=\"#Example\" aria-label=\"Example permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Example</h4>\n<p>For this example, we‚Äôll use the following commit graph, where commits <code class=\"language-text\">80c800</code>, <code class=\"language-text\">c85b4b</code>, and <code class=\"language-text\">3daedb</code> define uploads #1, #2, and #3, respectively.</p>\n<figure>\n  <img src=\"https://sourcegraphstatic.com/blog/commit-graph-optimizations/graph3.png\" alt=\"Sample commit graph\" class=\"no-shadow\">\n  <figcaption>A Git commit graph with code intelligence indexes attached to commits <code>80c800</code>, <code>c85b4b</code>, and <code>3daedb</code>.</figcaption>\n</figure>\n<p>The first step of the algorithm is to <a href=\"https://en.wikipedia.org/wiki/Topological_sorting\">topologically sort</a> each commit so that a commit is processed only after all of its parents are processed. Then we perform a simple <a href=\"https://en.wikipedia.org/wiki/Greedy_algorithm\">greedy process</a> to determine which uploads are visible at each stage of the commit. If a commit defines an upload, it is visible to that commit. Otherwise, the set of visible uploads for the commit is the same as the uploads visible from each parent (just at a higher distance).</p>\n<p>Because each parent can see a different set of uploads, we need to specify what happens when these sets <em>merge</em>. Take commit <code class=\"language-text\">e8331f</code> as an example. This commit can see both upload #3 via commit <code class=\"language-text\">3daedb</code>), as well as upload #1 via commit <code class=\"language-text\">9d9c37</code>. This yields a visible set <code class=\"language-text\">{(id=1, dist=4), (id=3 dist=1)}</code>. As part of the merge operation, we throw out the uploads that are farther away in favor of the ones that are closer. Similarly, we may see different uploads that tie in distance (as is the case with commit <code class=\"language-text\">69a5ed</code>, which can see both uploads #1 and #2 at the same distance). In these cases, we break ties deterministically by favoring the upload with the smallest identifier.</p>\n<p>We want to search the graph in both directions, so we perform the operation again but visit the commits in the reverse order. The set of forward-visible uploads and backwards-visible uploads can then be merged using the same rules as stated above. The complete set of visible uploads for each commit for this example commit graph are shown below.</p>\n<table>\n<thead>\n<tr>\n<th>Commit</th>\n<th>Descendant visibility</th>\n<th>Ancestor visibility</th>\n<th>Combined visibility</th>\n<th>Nearest upload</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>80c800</code></td>\n<td><code>{(id=1, dist=0)}</code></td>\n<td><code>{(id=1, dist=0)}</code></td>\n<td><code>{(id=1, dist=0)}</code></td>\n<td>#1</td>\n</tr>\n<tr>\n<td><code>d9c29f</code></td>\n<td><code>{(id=2, dist=1)}</code></td>\n<td><code>{(id=1, dist=1)}</code></td>\n<td><code>{(id=1, dist=1)}</code></td>\n<td>#1</td>\n</tr>\n<tr>\n<td><code>c85b4b</code></td>\n<td><code>{(id=2, dist=0)}</code></td>\n<td><code>{(id=2, dist=0)}</code></td>\n<td><code>{(id=2, dist=0)}</code></td>\n<td>#2</td>\n</tr>\n<tr>\n<td><code>69a5ed</code></td>\n<td><code>{(id=3, dist=2)}</code></td>\n<td><code>{(id=1, dist=1)}</code></td>\n<td><code>{(id=1, dist=1)}</code></td>\n<td>#1</td>\n</tr>\n<tr>\n<td><code>063211</code></td>\n<td><code>{}</code></td>\n<td><code>{(id=1, dist=2)}</code></td>\n<td><code>{(id=1, dist=2)}</code></td>\n<td>#1</td>\n</tr>\n<tr>\n<td><code>9d9c37</code></td>\n<td><code>{}</code></td>\n<td><code>{(id=1, dist=3)}</code></td>\n<td><code>{(id=1, dist=3)}</code></td>\n<td>#1</td>\n</tr>\n<tr>\n<td><code>f9727d</code></td>\n<td><code>{(id=3, dist=1)}</code></td>\n<td><code>{(id=1, dist=2)}</code></td>\n<td><code>{(id=3, dist=1)}</code></td>\n<td>#3</td>\n</tr>\n<tr>\n<td><code>3daedb</code></td>\n<td><code>{(id=3, dist=0)}</code></td>\n<td><code>{(id=3, dist=0)}</code></td>\n<td><code>{(id=3, dist=0)}</code></td>\n<td>#3</td>\n</tr>\n<tr>\n<td><code>e8331f</code></td>\n<td><code>{}</code></td>\n<td><code>{(id=3, dist=1)}</code></td>\n<td><code>{(id=3, dist=1)}</code></td>\n<td>#3</td>\n</tr>\n</tbody>\n</table>\n<p>The topological ordering of the commit graph and each traversal takes time linear to the size of the commit graph, making this entire procedure a linear time operation.</p>\n<h2 id=\"The-neglected-scaling-dimension\" style=\"position:relative;\"><a href=\"#The-neglected-scaling-dimension\" aria-label=\"The neglected scaling dimension permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>The neglected scaling dimension</h2>\n<p>Well, it‚Äôs not <em>quite</em> linear time if you take into account some of the stuff we claimed we could hand-wave away earlier: index files for different root directories.</p>\n<p>Many large repositories are built up of smaller, self-contained projects. Or, at least independently analyzable units of code. This enables a fairly coarse caching scheme: each time the repository is indexed (on <code class=\"language-text\">git push</code>, or periodically), only the units of code that have had explicitly changed since the last indexed commit need to be re-indexed.</p>\n<p>This means that there is no single nearest upload per commit: there is a nearest upload <em>per distinct indexing root directory</em>. To show the difference in output, we‚Äôll use the following commit graph, where:</p>\n<ul>\n<li>Commit <code class=\"language-text\">80c800</code> defines upload #1 rooted at the directory <code class=\"language-text\">/foo</code></li>\n<li>Commit <code class=\"language-text\">d9c29f</code> defines upload #2 rooted at the directory <code class=\"language-text\">/bar</code></li>\n<li>Commit <code class=\"language-text\">c85b4b</code> defines upload #3 rooted at the directory <code class=\"language-text\">/foo</code></li>\n<li>Commit <code class=\"language-text\">3daedb</code> defines upload #4 rooted at the directory <code class=\"language-text\">/baz</code></li>\n<li>Commit <code class=\"language-text\">69a5ed</code> defines upload #5 rooted at the directory <code class=\"language-text\">/bonk</code></li>\n</ul>\n<figure>\n  <img src=\"https://sourcegraphstatic.com/blog/commit-graph-optimizations/graph4.png\" alt=\"Sample commit graph\" class=\"no-shadow\">\n  <figcaption>A Git commit graph with code intelligence indexes rooted at different subdirectories.</figcaption>\n</figure>\n<table>\n<tr>\n    <th>Commit</th>\n    <th>Descendant visibility</th>\n    <th>Ancestor visibility</th>\n    <th>Combined visibility</th>\n</tr>\n<tr>\n    <td><code>80c800</code></td>\n    <td>\n        <code>(id=1, root=foo/, dist=0)</code>\n    </td>\n    <td>\n        <code>(id=1, root=foo/, dist=0)</code><br />\n        <code>(id=2, root=bar/, dist=1)</code><br />\n        <code>(id=4, root=bnk/, dist=2)</code><br />\n        <code>(id=5, root=baz/, dist=3)</code>\n    </td>\n    <td>\n        <code>(id=1, root=foo/, dist=0)</code><br />\n        <code>(id=2, root=bar/, dist=1)</code><br />\n        <code>(id=4, root=bnk/, dist=2)</code><br />\n        <code>(id=5, root=baz/, dist=3)</code>\n    </td>\n</tr>\n<tr>\n    <td><code>d9c29f</code></td>\n    <td>\n        <code>(id=1, root=foo/, dist=1)</code><br />\n        <code>(id=2, root=bar/, dist=0)</code>\n    </td>\n    <td>\n        <code>(id=2, root=bar/, dist=0)</code><br />\n        <code>(id=3, root=foo/, dist=1)</code><br />\n        <code>(id=5, root=baz/, dist=2)</code>\n    </td>\n    <td>\n        <code>(id=1, root=foo/, dist=1)</code><br />\n        <code>(id=2, root=bar/, dist=0)</code><br />\n        <code>(id=5, root=baz/, dist=2)</code>\n    </td>\n</tr>\n<tr>\n    <td><code>c85b4b</code></td>\n    <td>\n        <code>(id=2, root=bar/, dist=1)</code><br />\n        <code>(id=3, root=foo/, dist=0)</code>\n    </td>\n    <td>\n        <code>(id=3, root=foo/, dist=0)</code><br />\n        <code>(id=5, root=baz/, dist=1)</code>\n    </td>\n    <td>\n        <code>(id=2, root=bar/, dist=1)</code><br />\n        <code>(id=3, root=foo/, dist=0)</code><br />\n        <code>(id=5, root=baz/, dist=1)</code>\n    </td>\n</tr>\n<tr>\n    <td><code>69a5ed</code></td>\n    <td>\n        <code>(id=2, root=bar/, dist=2)</code><br />\n        <code>(id=3, root=foo/, dist=1)</code><br />\n        <code>(id=4, root=bnk/, dist=1)</code><br />\n        <code>(id=5, root=baz/, dist=0)</code>\n    </td>\n    <td>\n        <code>(id=5, root=baz/, dist=0)</code>\n    </td>\n    <td>\n        <code>(id=2, root=bar/, dist=2)</code><br />\n        <code>(id=3, root=foo/, dist=1)</code><br />\n        <code>(id=4, root=bnk/, dist=1)</code>\n    </td>\n</tr>\n<tr>\n    <td><code>f9727d</code></td>\n    <td>\n        <code>(id=1, root=foo/, dist=1)</code>\n    </td>\n    <td>\n        <code>(id=4, root=bnk/, dist=1)</code><br />\n        <code>(id=5, root=baz/, dist=2)</code>\n    </td>\n    <td>\n        <code>(id=1, root=foo/, dist=1)</code><br />\n        <code>(id=4, root=bnk/, dist=1)</code><br />\n        <code>(id=5, root=baz/, dist=2)</code>\n    </td>\n</tr>\n<tr>\n    <td><code>3daedb</code></td>\n    <td>\n        <code>(id=1, root=foo/, dist=2)</code><br />\n        <code>(id=4, root=bnk/, dist=0)</code>\n    </td>\n    <td>\n        <code>(id=4, root=bnk/, dist=0)</code><br />\n        <code>(id=5, root=baz/, dist=1)</code>\n    </td>\n    <td>\n        <code>(id=1, root=foo/, dist=2)</code><br />\n        <code>(id=4, root=bnk/, dist=0)</code><br />\n        <code>(id=5, root=baz/, dist=1)</code>\n    </td>\n</tr>\n<tr>\n    <td><code>063211</code></td>\n    <td>\n        <code>(id=2, root=bar/, dist=3)</code><br />\n        <code>(id=3, root=foo/, dist=2)</code><br />\n        <code>(id=4, root=bnk/, dist=2)</code><br />\n        <code>(id=5, root=baz/, dist=1)</code>\n    </td>\n    <td></td>\n    <td>\n        <code>(id=2, root=bar/, dist=3)</code><br />\n        <code>(id=3, root=foo/, dist=2)</code><br />\n        <code>(id=4, root=bnk/, dist=2)</code><br />\n        <code>(id=5, root=baz/, dist=1)</code>\n    </td>\n</tr>\n</table>\n<p>The size of the table here (relative to the simple table produced by a single-root repository) is the thing to note. Let‚Äôs say a repository has <em>n</em> commits and <em>m</em> distinctly indexable directories. Each commit then can see up to <em>m</em> uploads, which drastically balloons the cost of merging 2 sets of visible uploads. This further impacts performance in the presence of many merge commits.</p>\n<p><strong>We drastically underestimated the value of <em>m</em> for some enterprise customers.</strong></p>\n<p>One of our large enterprise customers, who is also one of our earliest adopters of LSIF-based code intelligence at scale, had completed an upgrade from Sourcegraph 3.17 to 3.20. After the upgrade, they realized they were no longer getting refreshed precise code intelligence and sent us this cubist Sydney Opera House of a graph, indicating that something was deeply wrong.</p>\n<figure>\n  <img src=\"https://sourcegraphstatic.com/blog/commit-graph-optimizations/oom.png\" alt=\"Worker OOM\">\n  <figcaption>Worker memory usage exploding, then falling suddenly after the process crashes.</figcaption>\n</figure>\n<p>The precise code intelligence worker process, which converts LSIF data uploaded by the user into our internal representation and writes it to our code intelligence data store, was ballooning in memory as jobs were processed. The extra memory hunger was extreme enough that the workers were consistently crashing with an ‚Äúout of memory‚Äù exception towards the end of each job. No job was completing successfully.</p>\n<p>After grabbing additional screenshots of our monitoring system, output to a few SQL queries, and a few pprof traces from the offending Go process, we proved that the culprit was <a href=\"https://sourcegraph.com/github.com/sourcegraph/sourcegraph@dc8beddf4066e30198c5ea368e6ee1092a6f4560/-/blob/enterprise/internal/codeintel/stores/dbstore/commit_graph.go#L37:6\">the function that determined the set of uploads visible at each commit</a> and knew we needed to find a way to reduce the resident memory required to do so.</p>\n<p>To give a sense of this user‚Äôs scale:</p>\n<ul>\n<li>Their commit graph contained ~40k commits</li>\n<li>They had ~18k LSIF uploads scattered throughout the graph</li>\n<li>Over all LSIF uploads, there were ~8k known distinct root directories</li>\n</ul>\n<p>While the commit graph itself was relatively small (the <a href=\"https://github.com/kubernetes/kubernetes\">k8s/k8s</a> commit graph is twice that size and could be processed without issue), the number of distinct roots was very large.</p>\n<h2 id=\"Memory-reduction-attempts\" style=\"position:relative;\"><a href=\"#Memory-reduction-attempts\" aria-label=\"Memory reduction attempts permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Memory reduction attempts</h2>\n<p>As an emergency <a href=\"https://github.com/sourcegraph/sourcegraph/pull/16086\">first attempt to reduce memory usage</a>, we were able to cut the amount of memory required to calculate visible uploads down by a factor of 4 (with the side effect of doubling the time it took to compute the commit graph). This was an acceptable trade-off, especially for a background process, and especially in a patch release meant to restore code intelligence to a high-volume private instance.</p>\n<p>The majority of the memory was being taken up by the following <code class=\"language-text\">UploadMeta</code> structure, which was the bookkeeping metadata we tracked for each visible commit at each upload. The root and indexer fields denote the directory where the indexer was run and the name of the indexing tool, respectively. An index with a smaller commit distance can <em>shadow</em> another only if these values are equivalent.</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> UploadMeta <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    UploadID        <span class=\"token builtin\">int</span>    <span class=\"token comment\">// identity part 1</span>\n    Root            <span class=\"token builtin\">string</span> <span class=\"token comment\">// identity part 2</span>\n    Indexer         <span class=\"token builtin\">string</span> <span class=\"token comment\">// identity part 3</span>\n    Distance        <span class=\"token builtin\">int</span>\n    AncestorVisible <span class=\"token builtin\">bool</span>   <span class=\"token comment\">// visible via parent?</span>\n    Overwritten     <span class=\"token builtin\">bool</span>   <span class=\"token comment\">// (more hand waving)!</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> CommitGraphView <span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>UploadMeta <span class=\"token comment\">// commit -> visible uploads</span></code></pre></div>\n<p>Two commit graph views must be created per repository: one traversing the commit graph in each direction. Each instance of an <code class=\"language-text\">UploadMeta</code> struct occupies 56 bytes in memory (calculated via <code class=\"language-text\">unsafe.Sizeof(UploadMeta{})</code>). At the scale above, these structs occupy nearly 30GB of memory, which excludes the values in the <code class=\"language-text\">Root</code> and <code class=\"language-text\">Indexer</code> fields. The values of the root field, in particular, were quite large (file paths up to 200 characters, the average hovering around 75 characters) and repeated very frequently. This was by far the dominating factor, as confirmed by the customer‚Äôs Go heap trace.</p>\n<p>We replaced the struct with the following set of data structures, which yields a much smaller yet semantically equivalent encoding to the commit graph view defined above.</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> UploadMeta <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    UploadID <span class=\"token builtin\">int</span>\n    Flags    <span class=\"token builtin\">uint32</span> <span class=\"token comment\">// distance + boolean flags above</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> FlagAncestorVisible <span class=\"token builtin\">uint32</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">30</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> FlagOverwritten     <span class=\"token builtin\">uint32</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">29</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">type</span> CommitGraphView <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    Meta   <span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>UploadMeta <span class=\"token comment\">// commit -> visible uploads</span>\n    Tokens <span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">string</span>          <span class=\"token comment\">// upload -> md5(&lt;root>:&lt;indexer>)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The first change is the introduction of the <code class=\"language-text\">Flags</code> field, which encodes the data previously stored in the <code class=\"language-text\">Distance</code>, <code class=\"language-text\">AncestorVisible</code>, and <code class=\"language-text\">Overwritten</code> fields. We encode the value of the booleans by setting the highest 2 bits on the 32-bit integer, and keep the remaining 30 lower bits to encode the distance. This still gives us enough room to encode a commit distance of over a billion, which‚Ä¶ if you‚Äôre looking that far back in your Git history I guarantee you‚Äôre going to get garbage out-of-date results. Now, the <code class=\"language-text\">UploadMeta</code> struct occupies only 16 bytes.</p>\n<p>The second change is the replacement of the root and indexer fields by a map from upload identifiers to a <em>hash</em> of the indexer and root fields. Because we use these values only to determine which uploads shadow other uploads, we don‚Äôt care about the actual values‚Äîwe only care if they‚Äôre equivalent or not. Our chosen hash always occupies 128 bits, which is a fraction of the size required by storing the full path string (75 characters take 600 bits to encode).</p>\n<p>This also greatly reduces the <em>multiplicity</em> of these strings in memory. Before, we were duplicating each indexer and root values for every <em>visible</em> upload. Now, we only need to store them for each <em>upload</em>, as the values do not change depending on where in the commit graph you are looking. Logically, this was simply a <a href=\"https://en.wikipedia.org/wiki/String_interning\">string interning</a> optimization.</p>\n<h2 id=\"Hitting-a-moving-target\" style=\"position:relative;\"><a href=\"#Hitting-a-moving-target\" aria-label=\"Hitting a moving target permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Hitting a moving target</h2>\n<p>While we were busy preparing a patch release to restore code intelligence to our customer, they had upgraded to the next version to fix an unrelated error they were experiencing in Sourcegraph‚Äôs search code.</p>\n<p>This made things <strong>far</strong> worse. In Sourcegraph 3.22, we moved the code that calculated the commit graph from the precise-code-intel-worker into the frontend in an effort to consolidate background and periodic processes into the same package. Our first stab at memory reduction wasn‚Äôt quite enough, and now the frontend pods were taking turns using all available memory and crashing.</p>\n<p>This made their entire instance unstable, and this series of events escalated us from a priority zero event to a <a href=\"https://devblogs.microsoft.com/oldnewthing/20081121-00/?p=20123\">priority now</a> event.</p>\n<p>We attacked the problem again, this time by ignoring large amounts of unneeded data. When we pull back the commit graph for a repository, it‚Äôs unlikely that we need the <em>entire</em> commit graph. There‚Äôs little sense in filling out the visibility of the long tail of historic commits, especially as its distance to the oldest LSIF upload grows over time. Now, we <a href=\"https://github.com/sourcegraph/sourcegraph/pull/16140\">entirely ignore</a> the portion of the commit graph that existed <em>before</em> the oldest known LSIF upload for that repository.</p>\n<p>In the same spirit, we can remove the explicit step of topologically sorting the commit graph in the application by instead <a href=\"https://github.com/sourcegraph/sourcegraph/pull/16270\">sorting it via the Git command</a>. This is basically the same win as replacing a <code class=\"language-text\">sort</code> call in your webapp with an <code class=\"language-text\">ORDER BY</code> clause in your SQL query. This further reduces the required memory as we‚Äôre no longer taking large amounts of stack space to traverse long chains of commits in the graph.</p>\n<p>Our <a href=\"https://github.com/sourcegraph/sourcegraph/pull/16368\">last change</a>, however, was the real heavy hitter and comes in 2 parts.</p>\n<h3 id=\"Part-1-Using-a-more-compact-data-structure\" style=\"position:relative;\"><a href=\"#Part-1-Using-a-more-compact-data-structure\" aria-label=\"Part 1 Using a more compact data structure permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Part 1: Using a more compact data structure</h3>\n<p>We‚Äôve so far been storing our commit graph in a map from commits to the set of uploads visible from that commit. When the number of distinct roots is large, the lists under each commit can also become quite large. Most notably, this makes the merge operation between 2 lists quite expensive in terms of both CPU and memory. CPU is increased as the merge procedure compares each pair of elements from the list in a trivial but quadratic nested loop. Memory is increased as merging 2 lists creates a third, all of which are live at the same time before any are a candidate for garbage collection.</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> visibleUploads <span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">string</span> <span class=\"token comment\">/* commit */</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>Upload <span class=\"token comment\">/* unsorted slice of visible uploads */</span></code></pre></div>\n<p>We make the observation that looking in a single direction, each commit can see at most 1 upload for a particular indexer and root. Instead of storing a flat list of visible uploads per commit, we can store a map from the indexer/root values to the visible upload with those properties. Merge operations now become linear (instead of quadratic) in the size of the input lists.</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> visibleUploads <span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">string</span> <span class=\"token comment\">/* commit */</span><span class=\"token punctuation\">]</span><span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">string</span> <span class=\"token comment\">/* indexer+root */</span><span class=\"token punctuation\">]</span>Upload <span class=\"token comment\">/* sole upload visible at root */</span></code></pre></div>\n<h3 id=\"Part-2-Ignoring-uninteresting-data\" style=\"position:relative;\"><a href=\"#Part-2-Ignoring-uninteresting-data\" aria-label=\"Part 2 Ignoring uninteresting data permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Part 2: Ignoring uninteresting data</h3>\n<p>We stop pre-calculating the set of visible uploads for <strong>every</strong> commit at once. We make the observation that for a large class of commits, the set of visible uploads are simply redundant information.</p>\n<figure>\n  <img src=\"https://sourcegraphstatic.com/blog/commit-graph-optimizations/graph5.png\" alt=\"Sample commit graph\" class=\"no-shadow\">\n  <figcaption>A Git commit graph with code intelligence attached to commits <code>68acd3</code> and <code>67e0bf</code>.</figcaption>\n</figure>\n<p>In the preceding commit graph, commits <code class=\"language-text\">91a565</code>, <code class=\"language-text\">52811d</code>, <code class=\"language-text\">7b1a18</code>, and <code class=\"language-text\">dd8578</code> are considered ‚Äútrivial‚Äù and can be easily and efficiently recalculated by performing a very fast single-path traversal up the graph to find a unique ancestor (or, descendant in the other direction) for which we store the set of visible uploads. The re-calculated visible uploads are then the visible uploads of this ancestor with an adjusted distance.</p>\n<p>The visibility for the remaining commits cannot be recalculated on the fly so easily due to one of the following conditions:</p>\n<ol>\n<li>The commit defines an upload,</li>\n<li>The commit has multiple parents; this would require a merge when traversing forwards,</li>\n<li>The commit has multiple children; this would require a merge when traversing backwards, or</li>\n<li>The commit has a sibling, <em>i.e.</em>, its parents have other children or its children have other parents. We ensure that we calculate the set of visible uploads of these commits to make downstream calculations easier. For example, we keep track of the visible uploads for commit <code class=\"language-text\">e43f5b</code> so that when we ask for the visible uploads from <em>both</em> parents of <code class=\"language-text\">599611</code> we do not have to perform a traversal.</li>\n</ol>\n<p>It turns out that 80% of our problematic commit graph can be recalculated in this way, meaning that we only need to keep 20% of the commit graph resident in memory at any given time.</p>\n<p>This last change turned out to be a <strong>huge</strong> win. When we started, the commit graph could only be calculated in 5 <strong>hours</strong> using 21GB of memory. Now, it takes 5 <strong>seconds</strong> and a single gigabyte. This is a ~3600x reduction in CPU and a ~20x reduction in memory.</p>\n<figure>\n  <img src=\"https://sourcegraphstatic.com/blog/commit-graph-optimizations/cpu-mem-fix.png\" alt=\"CPU and memory reduction\">\n  <figcaption>CPU and memory usage drastically after skipping calculation of visible uploads for \"trivial\" commits.</figcaption>\n</figure>\n<p>But of course the story isn‚Äôt over. We‚Äôre battling with the <a href=\"https://en.wikipedia.org/wiki/Project_management_triangle\">triple constraint</a> of latency, memory, and disk usage here. And since we‚Äôve optimized two of these properties, the third must necessarily suffer. Improvements in software often deal with similar time/space trade-offs. Removing a bad performance property of a system often doesn‚Äôt <em>remove</em> the bad property completely‚Äîit just pushes it into a corner that is less noticeable.</p>\n<p>In this case, it was <strong>very</strong> noticeable.</p>\n<figure>\n  <img src=\"https://sourcegraphstatic.com/blog/commit-graph-optimizations/full-disk.png\" alt=\"Critical db size\">\n  <figcaption>Sorry about your disk.</figcaption>\n</figure>\n<h2 id=\"Pick-3-low-latency-low-memory-usage-low-disk-usage-or-developer-sanity\" style=\"position:relative;\"><a href=\"#Pick-3-low-latency-low-memory-usage-low-disk-usage-or-developer-sanity\" aria-label=\"Pick 3 low latency low memory usage low disk usage or developer sanity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Pick 3: low latency, low memory usage, low disk usage, or developer sanity</h2>\n<p>Home stretch‚Äîwe can do this. To summarize:</p>\n<ol>\n<li>The speed at which we produce the commit graph is no longer a problem, and</li>\n<li>The resources we require to produce the commit graph is no longer a problem, but</li>\n<li>The amount of data we‚Äôre writing into PostgreSQL <em>is</em> a problem.</li>\n</ol>\n<p>Our <a href=\"https://github.com/sourcegraph/sourcegraph/pull/16636\">final and successful effort</a> to fix these time and space issues attacked the problem, once again, in 2 parts.</p>\n<p>First, we‚Äôve changed the commit graph traversal behavior to look only at ancestors. Since we started to ignore the bulk of the commit graph that existed before the first commit with LSIF data, looking into the <em>future</em> for LSIF data now has limited applicability. Generally, users will be on the tip of a branch (either the default branch, or a feature branch if reviewing a pull request). We can still answer code intelligence queries for these commits, as they necessarily occur after <em>some</em> LSIF data has been uploaded. Additionally, an unrelated <a href=\"https://github.com/sourcegraph/sourcegraph/pull/16733\">bug fix</a> caused descendant-direction traversals to increase memory usage. So at this point, it just seemed sensible to stop worrying about this reverse case, which was never truly necessary from a usability standpoint. Looking in one direction reduces the amount of data we need to store by about 50%.</p>\n<p>Second, we re-applied our <a href=\"#Part-2-Ignoring-uninteresting-data\">tricks</a> described in the previous section. We had good luck with throwing out huge amounts of data which we could efficiently recalculate when necessary, and save the resources that would otherwise be required to store them. This concept is known as <a href=\"https://en.wikipedia.org/wiki/Rematerialization\">rematerialization</a> in compiler circles, where values may be computed multiple times instead of storing and loading the already-computed value from memory. This is useful in the case where a load/store pair is more expensive than the computation itself, or if the load/stores would otherwise increase register pressure.</p>\n<p>Instead of writing the set of visible uploads per commit, what if we only store the visible uploads for commits that can‚Äôt be trivially recomputed? We‚Äôve already determined the set of commits that can be easily rematerialized‚Äîwe can just move the rematerialization from database insertion time to query time.</p>\n<p>However, it‚Äôs not as easy as just throwing out the data we don‚Äôt need. We were previously able to rematerialize the data we didn‚Äôt store because we still had access to the commit graph from which it was originally calculated. To recalculate the values cheaply (without pulling back the entire commit graph at query time) we need to encode some additional bookkeeping metadata in the database.</p>\n<p>We introduced a new table, <code class=\"language-text\">lsif_nearest_uploads_links</code>, which stores a link from each commit that can be trivially recomputed to its nearest ancestor with LSIF data. Queries are now a simple, constant-time lookup:</p>\n<ul>\n<li>If the commit exists in <code class=\"language-text\">lsif_nearest_uploads</code>, we simply use those visible uploads, otherwise</li>\n<li>If the commit exists in <code class=\"language-text\">lsif_nearest_upload_links</code>, we use the visible uploads attached to the ancestor.</li>\n</ul>\n<h4 id=\"Example-1\" style=\"position:relative;\"><a href=\"#Example-1\" aria-label=\"Example 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Example</h4>\n<p>We‚Äôll use the following commit graph again for our example. Here, commit <code class=\"language-text\">68acd3</code> defines upload #1, and <code class=\"language-text\">67e0bf</code> defines upload #2 (both with distinct indexing root directories).</p>\n<figure>\n  <img src=\"https://sourcegraphstatic.com/blog/commit-graph-optimizations/graph5.png\" alt=\"Sample commit graph\" class=\"no-shadow\">\n  <figcaption>A Git commit graph with code intelligence attached to commits <code>68acd3</code> and <code>67e0bf</code>.</figcaption>\n</figure>\n<p>The <code class=\"language-text\">lsif_nearest_uploads</code> table associates a commit with its visible uploads, just as before. But now, the number of records in the table is much, much smaller. The commits present in this table satisfy one of the properties described above that make the commit non-trivial to recompute.</p>\n<table>\n<thead>\n<tr>\n<th>repository</th>\n<th>commit</th>\n<th>upload_ids</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>github.com/sourcegraph/sample</td>\n<td><code>4a8a33</code></td>\n<td><code>[]</code></td>\n</tr>\n<tr>\n<td>github.com/sourcegraph/sample</td>\n<td><code>68acd3</code></td>\n<td><code>[1]</code></td>\n</tr>\n<tr>\n<td>github.com/sourcegraph/sample</td>\n<td><code>e43f5b</code></td>\n<td><code>[1]</code></td>\n</tr>\n<tr>\n<td>github.com/sourcegraph/sample</td>\n<td><code>67e0bf</code></td>\n<td><code>[2]</code></td>\n</tr>\n<tr>\n<td>github.com/sourcegraph/sample</td>\n<td><code>599611</code></td>\n<td><code>[1, 2]</code></td>\n</tr>\n</tbody>\n</table>\n<p>Luckily, some benefits compound one another here, and after we started ignoring traversing the graph in both directions, we can simplify these properties to only account for ancestor-direction traversals. Notably, commits whose parent has multiple children (<code class=\"language-text\">7e0471</code>, for example) no longer need to be stored because they were useful only in descendant-direction traversals (unless they are non-trivial for another reason). This further increases the number of trivially recomputable commits, saving even more space.</p>\n<p>The <code class=\"language-text\">lsif_nearest_uploads_links</code> table stores a <em>forwarding pointer</em> to the ancestor that has the same set of visible uploads.</p>\n<table>\n<thead>\n<tr>\n<th>repository</th>\n<th>commit</th>\n<th>ancestor_commit</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>github.com/sourcegraph/sample</td>\n<td><code>91a565</code></td>\n<td><code>68acd3</code></td>\n</tr>\n<tr>\n<td>github.com/sourcegraph/sample</td>\n<td><code>7e0471</code></td>\n<td><code>4a8a33</code></td>\n</tr>\n<tr>\n<td>github.com/sourcegraph/sample</td>\n<td><code>52811d</code></td>\n<td><code>7e0471</code></td>\n</tr>\n<tr>\n<td>github.com/sourcegraph/sample</td>\n<td><code>7b1a18</code></td>\n<td><code>599611</code></td>\n</tr>\n<tr>\n<td>github.com/sourcegraph/sample</td>\n<td><code>dd8578</code></td>\n<td><code>599611</code></td>\n</tr>\n</tbody>\n</table>\n<p>Note that for our instances with a large number of distinct indexing roots, this saves a <strong>massive</strong> amount of storage space. The majority of commits (> 80%) can link to an ancestor, which requires only referencing a fixed-size commit hash. The remaining minority of commits must explicitly list their visible uploads, of which there may be many thousands.</p>\n<p>This set of changes finally reduces disk usage from 100% to a much more reasonable 3-5%. üéâ</p>\n<p>And things <em>seem</em> to be remaining calm‚Ä¶</p>\n<h2 id=\"Lessons-learned-part-2\" style=\"position:relative;\"><a href=\"#Lessons-learned-part-2\" aria-label=\"Lessons learned part 2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Lessons learned (part 2)</h2>\n<p>In <a href=\"/blog/optimizing-a-code-intel-commit-graph/#Lessons-learned\">Part 1</a> we pointed out that databases are a hugely deep subject and knowing your tools deeply can get you fairly far in terms of performance. Unfortunately, with the wrong data model, it doesn‚Äôt matter how fast you can read or write it from the storage layer. You‚Äôre optimizing the wrong thing and missing the forest for the trees.</p>\n<p>In Part 2, we presented a fantastic way to ‚Äúoptimize the database‚Äù by reducing the size of our data set. Taking a step back away from the nitty-gritty details of an existing implementation to determine the shape of the data surrounding a problem can reveal much more straightforward and efficient ways to analyze and manipulate that data. This is especially true in a world with changing assumptions.</p>\n<h3 id=\"More-posts-like-this\" style=\"position:relative;\"><a href=\"#More-posts-like-this\" aria-label=\"More posts like this permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>More posts like this</h3>\n<ul>\n<li><a href=\"/blog/zoekt-memory-optimizations-for-sourcegraph-cloud/\">A 5x reduction in RAM usage with Zoekt memory optimizations</a></li>\n<li><a href=\"/blog/how-not-to-break-a-search-engine-unglamorous-engineering/\">How not to break a search engine or: What I learned about unglamorous engineering</a></li>\n<li><a href=\"/blog/avoiding-the-pitfalls-of-iteration-based-development/\">Avoiding the pitfalls of iteration-based development, explained in 5 pull requests</a></li>\n</ul>\n<!--\ndigraph G {\n  rankdir=\"LR\";\n  node [fontname=\"monospace\"];\n  edge[arrowhead=none];\n\n  main[shape=box,label=\"main\",color=grey];\n  branch[shape=box,label=\"feat/x\",color=grey];\n\n  g[label=\"323e23\",group=main];\n  f[label=\"d67b8d\",group=main, color=blue];\n  c[label=\"4c8d9d\",group=main];\n  a[label=\"f4fb06\",group=main, color=blue];\n  b[label=\"a36064\",group=main];\n  d[label=\"313082\",group=branch];\n  e[label=\"6a06fc\",group=branch];\n\n  g -> f; f -> c; c -> a; a -> b; b -> main;\n  c -> d; d -> e; e-> branch;\n}\n\ndigraph G {\n  rankdir=\"LR\";\n  node [fontname=\"monospace\"];\n  edge[arrowhead=none];\n  graph[nodesep=0.5];\n\n  main[shape=box,label=\"main\",color=grey,group=main];\n  branch1[shape=box,label=\"feat/x\",color=grey,group=branch];\n  branch2[shape=box,label=\"feat/y\",color=grey,group=branch2];\n\n  a[label=\"09210f\",group=main,color=blue];\n  b[label=\"3d2f27\",group=main];\n  e[label=\"1f64f9\",group=branch1];\n  l[label=\"2190d3\",group=branch1];\n  f[label=\"4a848f\",group=main];\n  g[label=\"5a24e4\",group=branch2];\n  j[label=\"703e33\",group=main];\n  k[label=\"6307e6\",group=main];\n\n  a -> b -> f -> k -> j;\n  a -> e -> l -> b;\n  b -> g -> j;\n\n  j -> main;\n  l -> branch1;\n  g -> branch2;\n}\n\ndigraph G {\n  rankdir=\"LR\";\n  node [fontname=\"monospace\"];\n  edge[arrowhead=none];\n  graph[nodesep=0.5];\n\n  a[label=\"80c800\",group=main,color=blue];\n  b[label=\"69a5ed\",group=main];\n  c[label=\"d9c29f\",group=branch1];\n  d[label=\"c85b4b\",group=branch1,color=blue];\n  e[label=\"063211\",group=main];\n  f[label=\"f9727d\",group=branch1];\n  g[label=\"3daedb\",group=branch1,color=blue];\n  h[label=\"9d9c37\",group=main];\n  j[label=\"e8331f\",group=main];\n\n  a -> b -> e -> h -> j;\n  a -> c -> d -> b;\n  b -> f -> g -> j;\n}\n\ndigraph G {\n  rankdir=\"LR\";\n  node [fontname=\"monospace\"];\n  edge[arrowhead=none];\n  graph[nodesep=0.5];\n\n  c[label=\"d9c29f\",group=branch1, color=red];\n  d[label=\"c85b4b\",group=branch1, color=blue];\n  a[label=\"80c800\",group=main, color=blue];\n  b[label=\"69a5ed\",group=main, color=gold];\n  e[label=\"063211\",group=main];\n  f[label=\"f9727d\",group=branch2];\n  g[label=\"3daedb\",group=branch2, color=green];\n\n  b -> e;\n  a -> c -> d -> b;\n  a -> f -> g -> b;\n}\n\ndigraph G {\n  rankdir=\"LR\";\n  node [fontname=\"monospace\"];\n  edge[arrowhead=none];\n  graph[nodesep=0.5];\n\n  a[label=\"4a8a33\",group=main];\n  b[label=\"68acd3\",group=main, color=blue];\n  c[label=\"91a565\",group=main];\n  d[label=\"e43f5b\",group=main];\n  e[label=\"599611\",group=main];\n  f[label=\"7b1a18\",group=main];\n  g[label=\"7e0471\",group=branch1];\n  h[label=\"52811d\",group=branch1];\n  j[label=\"67e0bf\",group=branch1,color=red];\n  i[label=\"dd8578\",group=main];\n\n  a -> g -> h -> j -> e;\n  a -> b -> c -> d -> e -> f -> i;\n}\n\ndigraph G {\n  rankdir=\"LR\";\n  node [fontname=\"monospace\"];\n  edge[arrowhead=none];\n  graph[nodesep=0.5];\n\n  a[label=\"a\",group=main, color=red];\n  b2[label=\"b\",group=f2];\n  b3[label=\"c\",group=f3];\n  b1[label=\"d\",group=main];\n  b4[label=\"e\",group=f4];\n  b5[label=\"f\",group=f5];\n  c[label=\"g\",group=main];\n  d2[label=\"h\",group=f2];\n  d3[label=\"i\",group=f3];\n  d1[label=\"j\",group=main];\n  d4[label=\"k\",group=f4];\n  d5[label=\"l\",group=f5];\n  e[label=\"m\",group=main, color=blue];\n\n  a -> b1 -> c -> d1 -> e;\n  a -> b2 -> c -> d2 -> e;\n  a -> b3 -> c -> d3 -> e;\n  a -> b4 -> c -> d4 -> e;\n  a -> b5 -> c -> d5 -> e;\n}\n\ndigraph G {\n  rankdir=\"LR\";\n  node [fontname=\"monospace\"];\n  edge[arrowhead=none];\n  graph[nodesep=0.5];\n\n  a[label=\"a\",group=\"main\",color=red];\n  b[label=\"...\",group=main, color=white];\n  c[label=\"b\",group=main];\n  d[label=\"...\",group=main, color=white];\n  e[label=\"c\",group=main, color=blue];\n\n  a -> b -> c -> d -> e;\n}\n-->\n<style>\n  figure .no-shadow { box-shadow: none; }\n  .workingtable-highlight td { color: #ffffff; background-color: #005cb9; }\n\n  figcaption {\n    text-align: center;\n    margin-top: -2rem;\n    font-style: italic;\n  }\n</style>"}