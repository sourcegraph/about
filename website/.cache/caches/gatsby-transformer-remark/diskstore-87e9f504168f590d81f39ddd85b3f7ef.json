{"expireTime":9007200905229171000,"key":"transformer-remark-markdown-html-53e368fb892c56e25582d0ed55be18c0-gatsby-remark-autolink-headersgatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-unwrap-imagesgatsby-remark-imagesgatsby-remark-smartypants-","val":"<p>Sourcegraph 3.35 is now available! Here are some highlights from this release:</p>\n<h2 id=\"Precise-Code-Intelligence-for-Java-Scala-and-Kotlin\" style=\"position:relative;\"><a href=\"#Precise-Code-Intelligence-for-Java-Scala-and-Kotlin\" aria-label=\"Precise Code Intelligence for Java Scala and Kotlin permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Precise Code Intelligence for Java, Scala, and Kotlin</h2>\n<p>Sourcegraph now provides precise Code Intelligence for Java, Scala, and Kotlin. You can now get compiler-accurate “Go to definition” and “Find references” within a Git repository and all transitive dependencies of your codebase. You can find Kotlin or Scala usages from Java code and vice versa, which is particularly useful for mixed-language repositories. <a href=\"https://about.sourcegraph.com/blog/java-scala-kotlin-code-intelligence/\">Read more about precise Code Intelligence for Java, Scala, and Kotlin in our blog post</a>, and check out our <a href=\"https://sourcegraph.github.io/lsif-java/\">lsif-java documentation</a> for detailed setup instructions and build-tooling compatibility.\n<img class=\"blog-image\" title=\"JVM precise code intelligence\" alt=\"An example of the find references feature being used in a Kotlin source file and returning examples in Scala.\" src=\"https://storage.googleapis.com/sourcegraph-assets/blog/3.35/preciseJVMintelligence.png\"></p>\n<h2 id=\"Efficiently-update-multiple-branches-of-a-repository-with-Batch-Changes\" style=\"position:relative;\"><a href=\"#Efficiently-update-multiple-branches-of-a-repository-with-Batch-Changes\" aria-label=\"Efficiently update multiple branches of a repository with Batch Changes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Efficiently update multiple branches of a repository with Batch Changes</h2>\n<p>Bumping up a dependency or changing boilerplate code in several branches of the same repository is painful, repetitive work that’s a great candidate for a batch change. Batch Changes now allows you to publish changesets to <a href=\"https://docs.sourcegraph.com/batch_changes/references/batch_spec_yaml_reference#on-repository\">several branches in the same repository</a>, rather than a single branch per repository. This is particularly useful, for example, when long-lived branches are used to define versions or releases.</p>"}