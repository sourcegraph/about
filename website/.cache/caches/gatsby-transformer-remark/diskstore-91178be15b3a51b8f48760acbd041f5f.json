{"expireTime":9007200905229170000,"key":"transformer-remark-markdown-ast-8cb16ac8ee14aa0a26848291bd72df77-gatsby-remark-autolink-headersgatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-unwrap-imagesgatsby-remark-imagesgatsby-remark-smartypants-","val":{"type":"root","children":[{"type":"html","value":"<p style=\"text-align: center\">\n  <iframe width=\"560\" height=\"315\" src=\"https://www.youtube-nocookie.com/embed/sSkx5SVc2OA\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</p>","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":4,"column":5,"offset":250},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"TypeScript and ECMAScript have some of the most beautiful constructs and syntaxes to do parallel, non-blocking programming—but unfortunately, only for standard APIs like fetch in the browser or file IO in Node. When implementing anything CPU-bound in TypeScript, offloading it into a different, parallel execution context and exposing an equally type-safe and flexible API for it is non-trivial.","position":{"start":{"line":6,"column":1,"offset":252},"end":{"line":6,"column":396,"offset":647},"indent":[]}}],"position":{"start":{"line":6,"column":1,"offset":252},"end":{"line":6,"column":396,"offset":647},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"At the ","position":{"start":{"line":8,"column":1,"offset":649},"end":{"line":8,"column":8,"offset":656},"indent":[]}},{"type":"link","title":null,"url":"https://www.meetup.com/seattle-ts/events/264757065/","children":[{"type":"text","value":"2019 TSConf pre-meetup in Seattle","position":{"start":{"line":8,"column":9,"offset":657},"end":{"line":8,"column":42,"offset":690},"indent":[]}}],"position":{"start":{"line":8,"column":8,"offset":656},"end":{"line":8,"column":96,"offset":744},"indent":[]}},{"type":"text","value":", I presented the different options for implementing parallel APIs in userland, starting from any-typed message passing, to utilizing advanced TypeScript features such as mapped types, conditional types and function parameter tuple types to support remote procedure calls, fully-flexible property access, and live references to mutable objects.","position":{"start":{"line":8,"column":96,"offset":744},"end":{"line":8,"column":440,"offset":1088},"indent":[]}}],"position":{"start":{"line":8,"column":1,"offset":649},"end":{"line":8,"column":440,"offset":1088},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"After watching this talk, you’ll have learned how to implement truly-parallel CPU-bound APIs in userland, and how to expose them to other threads, Node processes or even over the network in a fully type-safe manner, all with zero boilerplate code.","position":{"start":{"line":10,"column":1,"offset":1090},"end":{"line":10,"column":248,"offset":1337},"indent":[]}}],"position":{"start":{"line":10,"column":1,"offset":1090},"end":{"line":10,"column":248,"offset":1337},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":11,"column":1,"offset":1338}}}}