{"expireTime":9007200905229171000,"key":"transformer-remark-markdown-html-d0b6eea54a2ef06f4cf60af80b89305d-gatsby-remark-autolink-headersgatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-unwrap-imagesgatsby-remark-imagesgatsby-remark-smartypants-","val":"<img src=\"/blog/optimizing-code-intelligence-commit-graph.png\" alt=\"Optimizing code intelligence commit graph graphic\">\n<p>Sourcegraph’s <a href=\"https://handbook.sourcegraph.com/engineering/code-intelligence\">Code Intelligence</a> team builds tools and services that provide contextual information around code. These enable users to perform fast, comprehensive, and accurate code navigation, and to surface dependency relationships across projects, repositories, and languages. In this post I’ll dive into how Sourcegraph can resolve code intelligence queries using data from older commits when data on the requested commit is not yet available. In <a href=\"/blog/optimizing-a-code-intel-commit-graph-part-2/\">Part 2</a>, we’ll cover how additional scalability concerns presented themselves and how we tackled them.</p>\n<p>Since the first version of Sourcegraph, precise code navigation has been a first-order concern. Its ability to provide compiler-accurate code navigation in a web-based interface is a superpower for our users.</p>\n<figure>\n  <img src=\"https://sourcegraphstatic.com/precise-xrepo-j2d.gif\" alt=\"Cross-repository jump to definition\">\n  <figcaption>Cross-repository jump to definition from a use in <code>sourcegraph/sourcegraph</code> to a definition in <code>gorilla/mux</code>.</figcaption>\n</figure>\n<p>The <a href=\"/blog/evolution-of-the-precise-code-intel-backend/\">journey to our current implementation</a> began in February 2019 when we shifted our efforts from running Language Servers alongside Sourcegraph to pre-indexing source code via the Language Server Index Format (LSIF) and uploading it to Sourcegraph. This change introduced a new requirement of the user: they are now responsible for producing and uploading the LSIF index.</p>\n<p>The method to produce an LSIF index is highly variable and depends on many factors. If a repository is not too large, a user may wish to create a new index on every commit in their CI. If a repository is very large (the monorepo case), or an organization has a large number of repositories, it may be better to instead index code periodically and upload a refreshed index. Google uses such a scheduled job to refresh their monorepo’s index twice a day.</p>\n<p>Regardless of the indexing method, it is always possible for a user to find themselves browsing a commit for which Sourcegraph has not received an index. This can happen due to a slow job in a continuous integration server, a backed-up indexing processing queue, or the commit may simply be skipped in the case of a periodic refresh.</p>\n<p>This is a glaring hole in the feature. The majority of users are exploring code on the tip of a branch, which is the <em>least</em> likely commit to have an index immediately after it’s been pushed to the code host.</p>\n<p>In order to plug this hole, we determine the set of nearby commits for which Sourcegraph has received an index, query these indexes on behalf of the requested commit, then adjust the resulting locations (file paths and ranges within a document) using the Git diff between the commits as a guide. This enables Sourcegraph to respond with precise results to requests on commits missing an index.</p>\n<h2 id=\"Tracking-cross-commit-index-visibility\" style=\"position:relative;\"><a href=\"#Tracking-cross-commit-index-visibility\" aria-label=\"Tracking cross commit index visibility permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Tracking cross-commit index visibility</h2>\n<p>The first step in this process is to <a href=\"https://github.com/sourcegraph/sourcegraph/pull/5691\">track how commits of a repository relate to one another</a>. Unfortunately, the service providing the code intelligence features was separated (by design) from the rest of the product. We had only recently <a href=\"https://github.com/sourcegraph/sourcegraph/pull/5740\">gained access to the Sourcegraph PostgreSQL database</a> used by the rest of the application, and no other team was tracking commit information. The source of truth for that data was another service called gitserver, which required both an RPC call and a subprocess to access.</p>\n<p>Our initial stab at this problem was to introduce 2 new tables to PostgreSQL: <code class=\"language-text\">commits</code> and <code class=\"language-text\">lsif_data_markers</code>.</p>\n<p>The <code class=\"language-text\">commits</code> table stores data similar to a flattened version of the output from <code class=\"language-text\">git log --all --pretty=&#39;%H %P&#39;</code> (a commit followed by a list of its parents), for each repository. Example values for this table are shown below to aid our running example. This table would generally store the full 40-character commit ID—we are abbreviating them for brevity here.</p>\n<table>\n<thead>\n<tr>\n<th>repository</th>\n<th>commit</th>\n<th>parent_commit</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>github.com/sourcegraph/sample</td>\n<td><code>a36064</code></td>\n<td><code>f4fb06</code></td>\n</tr>\n<tr>\n<td>github.com/sourcegraph/sample</td>\n<td><code>f4fb06</code></td>\n<td><code>4c8d9d</code></td>\n</tr>\n<tr>\n<td>github.com/sourcegraph/sample</td>\n<td><code>313082</code></td>\n<td><code>4c8d9d</code></td>\n</tr>\n<tr>\n<td>github.com/sourcegraph/sample</td>\n<td><code>6a06fc</code></td>\n<td><code>313082</code></td>\n</tr>\n<tr>\n<td>github.com/sourcegraph/sample</td>\n<td><code>4c8d9d</code></td>\n<td><code>d67b8d</code></td>\n</tr>\n<tr>\n<td>github.com/sourcegraph/sample</td>\n<td><code>d67b8d</code></td>\n<td><code>323e23</code></td>\n</tr>\n<tr>\n<td>github.com/sourcegraph/sample</td>\n<td><code>323e23</code></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>This table is synchronized with the source of truth in gitserver whenever we receive a request for a commit that we didn’t know about previously. A row present in the <code class=\"language-text\">lsif_data_markers</code> table denotes that an index was uploaded for a particular commit. Example values for this table are also shown below.</p>\n<table>\n<thead>\n<tr>\n<th>repository</th>\n<th>commit</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>github.com/sourcegraph/sample</td>\n<td><code>f4fb06</code></td>\n</tr>\n<tr>\n<td>github.com/sourcegraph/sample</td>\n<td><code>d67b8d</code></td>\n</tr>\n<tr>\n<td>github.com/sourcegraph/sample</td>\n<td><code>0eed16</code></td>\n</tr>\n</tbody>\n</table>\n<p>Together, these 2 tables enable us to recursively search up and down the commit graph starting at a particular requested commit, and stop the search once we reach a commit that has index data. The following <a href=\"https://www.postgresql.org/docs/13/queries-with.html\">recursive common table expression</a> does just that.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- lineage is a table expression that traverses the commit graph for the given</span>\n<span class=\"token comment\">-- repository starting at the given commit, and returns the set of commit records</span>\n<span class=\"token comment\">-- reachable via ancestor and descendant paths.</span>\n<span class=\"token keyword\">WITH</span> RECURSIVE lineage<span class=\"token punctuation\">(</span>repository<span class=\"token punctuation\">,</span> <span class=\"token string\">\"commit\"</span><span class=\"token punctuation\">,</span> parent_commit<span class=\"token punctuation\">,</span> distance<span class=\"token punctuation\">,</span> direction<span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token comment\">-- Non-recursive term: Seed the lineage table with the commit we're starting</span>\n    <span class=\"token comment\">-- the traversal from.</span>\n\n    <span class=\"token keyword\">SELECT</span> l<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> <span class=\"token punctuation\">(</span>\n        <span class=\"token comment\">-- seed ancestor search</span>\n        <span class=\"token keyword\">SELECT</span> c<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'A'</span> <span class=\"token keyword\">FROM</span> commits c <span class=\"token keyword\">UNION</span>\n        <span class=\"token comment\">-- seed descendant search</span>\n        <span class=\"token keyword\">SELECT</span> c<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'D'</span> <span class=\"token keyword\">FROM</span> commits c\n    <span class=\"token punctuation\">)</span> l\n    <span class=\"token keyword\">WHERE</span> l<span class=\"token punctuation\">.</span>repository <span class=\"token operator\">=</span> $<span class=\"token number\">1</span> <span class=\"token operator\">AND</span> l<span class=\"token punctuation\">.</span><span class=\"token string\">\"commit\"</span> <span class=\"token operator\">=</span> $<span class=\"token number\">2</span>\n\n    <span class=\"token keyword\">UNION</span>\n\n    <span class=\"token comment\">-- Recursive term: Find the \"frontier\" of lineage, which is the direct parents</span>\n    <span class=\"token comment\">-- of each commit currently in lineage when searching in the ancestor direction,</span>\n    <span class=\"token comment\">-- and the direct children of each commit searching in the descendant direction.</span>\n\n    <span class=\"token keyword\">SELECT</span>\n        c<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span><span class=\"token punctuation\">,</span>\n        l<span class=\"token punctuation\">.</span>distance <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n        l<span class=\"token punctuation\">.</span>direction\n    <span class=\"token keyword\">FROM</span>\n        lineage l\n    <span class=\"token keyword\">JOIN</span>\n        commits c\n    <span class=\"token keyword\">ON</span>\n        c<span class=\"token punctuation\">.</span>repository <span class=\"token operator\">=</span> l<span class=\"token punctuation\">.</span>repository <span class=\"token operator\">AND</span> <span class=\"token punctuation\">(</span>\n            <span class=\"token comment\">-- parent coming from child</span>\n            <span class=\"token punctuation\">(</span>l<span class=\"token punctuation\">.</span>direction <span class=\"token operator\">=</span> <span class=\"token string\">'A'</span> <span class=\"token operator\">AND</span> c<span class=\"token punctuation\">.</span><span class=\"token string\">\"commit\"</span> <span class=\"token operator\">=</span> l<span class=\"token punctuation\">.</span>parent_commit<span class=\"token punctuation\">)</span> <span class=\"token operator\">OR</span>\n            <span class=\"token comment\">-- child coming from parent</span>\n            <span class=\"token punctuation\">(</span>l<span class=\"token punctuation\">.</span>direction <span class=\"token operator\">=</span> <span class=\"token string\">'D'</span> <span class=\"token operator\">AND</span> c<span class=\"token punctuation\">.</span>parent_commit <span class=\"token operator\">=</span> l<span class=\"token punctuation\">.</span><span class=\"token string\">\"commit\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">-- limit traversal distance</span>\n    <span class=\"token keyword\">WHERE</span> l<span class=\"token punctuation\">.</span>distance <span class=\"token operator\">&lt;</span> $<span class=\"token number\">3</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">-- Select the first row from lineage with LSIF data. This will return such a commit</span>\n<span class=\"token comment\">-- with a minimized distance, as the table expression has the same ordering as the</span>\n<span class=\"token comment\">-- traversal by construction.</span>\n<span class=\"token keyword\">SELECT</span> l<span class=\"token punctuation\">.</span><span class=\"token string\">\"commit\"</span>\n<span class=\"token keyword\">FROM</span> lineage l\n<span class=\"token keyword\">WHERE</span> <span class=\"token keyword\">EXISTS</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">SELECT</span> <span class=\"token number\">1</span> <span class=\"token keyword\">FROM</span> lsif_data_markers m <span class=\"token keyword\">WHERE</span> m<span class=\"token punctuation\">.</span>repository <span class=\"token operator\">=</span> l<span class=\"token punctuation\">.</span>repository <span class=\"token operator\">AND</span> m<span class=\"token punctuation\">.</span><span class=\"token string\">\"commit\"</span> <span class=\"token operator\">=</span> l<span class=\"token punctuation\">.</span><span class=\"token string\">\"commit\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">LIMIT</span> <span class=\"token number\">1</span></code></pre></div>\n<p>This query maintains a worklist (the query-local <code class=\"language-text\">lineage</code> table) seeded by the requested commit, and grows by finding untracked commits that are either a parent (the ancestor <code class=\"language-text\">A</code> direction) or a child (the descendant <code class=\"language-text\">D</code> direction) of a commit already in the worklist and inserting it. The table is implicitly ordered by its insertions, so the final select returns the commit with index data that also has the smallest commit distance to the requested commit. The <code class=\"language-text\">WHERE</code> clause inside of the CTE is there to limit the size of the working table, which can be pathologically large in the case of a large commit graph and no uploads visible from a given commit.</p>\n<h4 id=\"Example\" style=\"position:relative;\"><a href=\"#Example\" aria-label=\"Example permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Example</h4>\n<p>The values of the tables above represent the following hypothetical commit graph, where <code class=\"language-text\">a36064</code> is the head of the <code class=\"language-text\">main</code> branch, <code class=\"language-text\">6106fc</code> is the head of the feature branch <code class=\"language-text\">feat/x</code>, and the commits with uploads (<code class=\"language-text\">f4fb06</code> and <code class=\"language-text\">d67b8d</code>) are drawn in blue.</p>\n<figure>\n  <img src=\"https://sourcegraphstatic.com/blog/commit-graph-optimizations/graph1.png\" alt=\"Sample commit graph\" class=\"no-shadow\">\n  <figcaption>A Git commit graph with mainline branch <code>main</code> and a feature branch <code>x</code>.</figcaption>\n</figure>\n<p>Running the query above from the commit <code class=\"language-text\">313082</code> produces the following CTE results over 3 iterations before halting, and ultimately returns <code class=\"language-text\">d67b8d</code> as the nearest commit visible to the target query.</p>\n<table>\n<thead>\n<tr>\n<th>iteration</th>\n<th>commit</th>\n<th>parent_commit</th>\n<th>distance</th>\n<th>direction</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td><code>313082</code></td>\n<td><code>4c8d9d</code></td>\n<td>0</td>\n<td>A</td>\n</tr>\n<tr>\n<td>1</td>\n<td><code>313082</code></td>\n<td><code>4c8d9d</code></td>\n<td>0</td>\n<td>D</td>\n</tr>\n<tr>\n<td>2</td>\n<td><code>4c8d9d</code></td>\n<td><code>d67b8d</code></td>\n<td>1</td>\n<td>A</td>\n</tr>\n<tr>\n<td>2</td>\n<td><code>6a06fc</code></td>\n<td><code>313082</code></td>\n<td>1</td>\n<td>D</td>\n</tr>\n<tr>\n<td>3</td>\n<td><code>d67b8d</code></td>\n<td><code>323e23</code></td>\n<td>2</td>\n<td>A</td>\n</tr>\n</tbody>\n</table>\n<p>Of particular note is that we don’t visit <em>sibling</em> commits: once we reach a commit by travelling in the ancestor direction, we can’t suddenly flip direction. Maintaining the direction heading during traversal ensures that the algorithm will eventually terminate.</p>\n<h2 id=\"Performance-improvements\" style=\"position:relative;\"><a href=\"#Performance-improvements\" aria-label=\"Performance improvements permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Performance improvements</h2>\n<p>Unfortunately, our first stab at an implementation had a number of rather disappointing performance characteristics, as first stabs typically do. The query above is basically a SQL translation of an imperative graph-walking algorithm. Thinking of the query in these terms makes it easier to see that the runtime cost of the query will increase proportionally to the distance travelled through the graph.</p>\n<p>The following query plan shows an execution trace that visited around 10 commits (the resulting commit was 5 commits away, and we search in both directions). This query takes about 40ms, which is already a high cost for a query that runs every time a user hovers over an identifier.</p>\n<figure>\n  <img src=\"https://sourcegraphstatic.com/blog/commit-graph-optimizations/fast.png\" alt=\"Fast query plan\">\n  <figcaption>\n    Query plan of a commit graph traversal visiting 10 commits.\n    <br>\n    <small>Diagram produced from Alex Tatiyants' <a href=\"https://github.com/AlexTatiyants/pev\">Postgres Explain Visualizer</a>.</small>\n  </figcaption>\n</figure>\n<p>The following query plan shows an execution trace that visited around 100 commits (the resulting commit was 44 commits away). This query takes about 330ms, which is well over the <a href=\"https://www.computer.org/csdl/pds/api/csdl/proceedings/download-article/12OmNyQYtlZ/pdf\">noticeable latency threshold</a>.</p>\n<figure id=\"query-plan\">\n  <img src=\"https://sourcegraphstatic.com/blog/commit-graph-optimizations/slow.png\" alt=\"Slow query plan\">\n  <figcaption>Query plan of a commit graph traversal visiting 100 commits.</figcaption>\n</figure>\n<p><a href=\"https://github.com/sourcegraph/sourcegraph/pull/5946\">Adding additional indexes</a> to the <code class=\"language-text\">commits</code> table helped a bit, but did not fundamentally change the performance characteristics of the query. An even larger pathology was discovered in repositories with a large number of merge commits. In order to understand the performance issue, it’s important first to understand how the recursive query evaluation works in the case of duplicates, which was initially unintuitive to us. Paraphrasing the <a href=\"https://www.postgresql.org/docs/13/queries-with.html\">PostgreSQL documentation</a>, recursive queries are evaluated with the following steps (emphasis ours):</p>\n<ol>\n<li>Evaluate the non-recursive term and <strong>discard duplicate rows</strong></li>\n<li>Insert rows into result set as well as a temporary working table</li>\n<li>\n<p>While the working table is not empty:</p>\n<ol>\n<li>Evaluate the recursive term by substituting the recursive self-reference with the working table and <strong>discard duplicate rows</strong></li>\n<li>Insert rows into result set as well as a new temporary intermediate table</li>\n<li>Replace the working table with the intermediate table and empty the intermediate table</li>\n</ol>\n</li>\n</ol>\n<p>A row is a duplicate of another row (from PostgreSQL’s point of view) if they both contain the same set of values. However, from our point of view, a row is a duplicate of another row if only their commit values match. After all, we’re running a breadth-first search over a graph and by the time we’ve seen a commit for the second time, we’ve already seen it via the shortest path. This mismatch in expectations don’t cost us correctness, but it does cause performance problems and the pain that comes with it.</p>\n<h4 id=\"Example-1\" style=\"position:relative;\"><a href=\"#Example-1\" aria-label=\"Example 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Example</h4>\n<p>The following hypothetical commit graph contains a number of feature branches that are eventually merged back into mainline, unlike our previous example where all commits had at most one parent.</p>\n<figure>\n  <img src=\"https://sourcegraphstatic.com/blog/commit-graph-optimizations/graph2.png\" alt=\"Sample commit graph\" class=\"no-shadow\">\n  <figcaption>A Git commit graph with feature branches <code>x</code> and <code>y</code> merged into <code>main</code>.</figcaption>\n</figure>\n<p>Running the query above from the commit <code class=\"language-text\">703e33</code> produces the following CTE results over the first 4 iterations.</p>\n<table>\n<tr><th>iteration</th><th>commit</th><th>parent_commit</th><th>distance</th><th>direction</th></tr>\n<tr><td>1</td><td><code>703e33</code></td><td><code>6307e6</code></td><td>0</td><td>A</td></tr>\n<tr><td>1</td><td><code>703e33</code></td><td><code>6307e6</code></td><td>0</td><td>D</td></tr>\n<tr><td>1</td><td><code>703e33</code></td><td><code>5a24e4</code></td><td>0</td><td>A</td></tr>\n<tr><td>1</td><td><code>703e33</code></td><td><code>5a24e4</code></td><td>0</td><td>D</td></tr>\n<tr><td>2</td><td><code>5a24e4</code></td><td><code>3d2f27</code></td><td>1</td><td>A</td></tr>\n<tr><td>2</td><td><code>6307e6</code></td><td><code>4a848f</code></td><td>1</td><td>A</td></tr>\n<tr class=\"workingtable-highlight\"><td>3</td><td><code>3d2f27</code></td><td><code>09210f</code></td><td>2</td><td>A</td></tr>\n<tr class=\"workingtable-highlight\"><td>3</td><td><code>3d2f27</code></td><td><code>2190d3</code></td><td>2</td><td>A</td></tr>\n<tr><td>3</td><td><code>4a848f</code></td><td><code>3d2f27</code></td><td>2</td><td>A</td></tr>\n<tr><td>4</td><td><code>09210f</code></td><td></td><td>3</td><td>A</td></tr>\n<tr><td>4</td><td><code>2190d3</code></td><td><code>1f64f9</code></td><td>3</td><td>A</td></tr>\n<tr class=\"workingtable-highlight\"><td>4</td><td><code>3d2f27</code></td><td><code>09210f</code></td><td>3</td><td>A</td></tr>\n<tr class=\"workingtable-highlight\"><td>4</td><td><code>3d2f27</code></td><td><code>2190d3</code></td><td>3</td><td>A</td></tr>\n</table>\n<p>Notice that there are 2 ways to get from commit <code class=\"language-text\">7033ee</code> to commit <code class=\"language-text\">3d2f27</code>, therefore the entries for <code class=\"language-text\">3d2f27</code> are duplicated in the CTE results (and therefore the working table). Also notice that the number of <em>new</em> rows per iteration is growing as the iteration count rises in such graphs. <strong>For some configuration of input, this query is <a href=\"https://accidentallyquadratic.tumblr.com/\">quadratic</a> instead of linear.</strong></p>\n<p>What we <em>wanted</em> to happen was for the “duplicate rows” not to be inserted into the working table at all. Unfortunately, each record in this example is distinct due to the differing path lengths—a detail we glossed over when designing this query in the first place. Another classic case of the computer doing what you <em>told</em> it to do instead of what you <em>wanted</em> it to do. 🙄</p>\n<hr>\n<p>Our <a href=\"https://github.com/sourcegraph/sourcegraph/pull/5980\">first attempt to optimize this query</a> directly tackled the problem of duplicate rows in the worktable, as shown in the above example. This change simply removes the <code class=\"language-text\">distance</code> column from the lineage table expression. The “duplicates” that we now throw out are records for commits that have already been seen via a shorter path. This required that we move the limiting condition from table expression into the select, which changes the behavior very slightly (it now limits by working set size, not by distance, which was an acceptable trade-off for the performance increase).</p>\n<p><a href=\"https://github.com/sourcegraph/sourcegraph/pull/5984\">Additional efforts to optimize this query</a> were highly successful. The following chart compares the query latency of the original query (<em>quadratic</em>, blue) and the optimized query (<em>fast linear</em>, green), and we’ve <em>very clearly</em> removed the term that was creating the quadratic behavior.</p>\n<figure>\n  <img src=\"https://user-images.githubusercontent.com/1387653/66709486-a9813900-ed22-11e9-9519-d9a9c098b37d.png\" alt=\"Query latency comparison\" class=\"no-shadow\">\n  <figcaption>Comparison of latencies between different Git commit graph traversal queries in PostgreSQL.</figcaption>\n</figure>\n<p>Looking back at <a href=\"#query-plan\">the query plan above</a>, the we can now determine that the culprit drastically affecting performance is the index scan within the nested loop. Ignore the sequential scan block here, which is usually suspicious but happens to be a red herring in this case. The sequential scan happens in favor of an index because of the small size of the <code class=\"language-text\">lsif_data_markers</code> dataset. When the table becomes larger, it is replaced with an efficient index scan.</p>\n<p><strong>But index scans are supposed to be fast!</strong> Well, they <em>are</em> faster than a sequential scan, but may not be as fast as an index scan that uses a different index, or uses an index in a slightly different way. This particular scan fetches rows from the commits table using only <code class=\"language-text\">c.repository = l.repository</code> as the index condition. This pulls back literally the entire commit graph for the repository and each row is then filtered based on the remaining conditions. There are two multicolumn indexes that <em>could</em> conceivably be used here: one on (<code class=\"language-text\">repository</code>, <code class=\"language-text\">commit</code>) and one on (<code class=\"language-text\">repository</code>, <code class=\"language-text\">parent_commit</code>). However, the following filter conditions would require the use of <em>both</em> indexes, which PostgreSQL seems unable to do, or unwilling to do due to an inaccurate query cost estimate.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token punctuation\">(</span>l<span class=\"token punctuation\">.</span>direction <span class=\"token operator\">=</span> <span class=\"token string\">'A'</span> <span class=\"token operator\">AND</span> c<span class=\"token punctuation\">.</span><span class=\"token keyword\">commit</span> <span class=\"token operator\">=</span> l<span class=\"token punctuation\">.</span>parent_commit<span class=\"token punctuation\">)</span> <span class=\"token operator\">OR</span> <span class=\"token punctuation\">(</span>l<span class=\"token punctuation\">.</span>direction <span class=\"token operator\">=</span> <span class=\"token string\">'D'</span> <span class=\"token operator\">AND</span> c<span class=\"token punctuation\">.</span>parent_commit <span class=\"token operator\">=</span> l<span class=\"token punctuation\">.</span><span class=\"token keyword\">commit</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>To reduce the cost of this index scan, we rewrote the recursive term within the table expression above (the second term of the <code class=\"language-text\">UNION</code>). Instead of using a <code class=\"language-text\">SELECT</code> with an <code class=\"language-text\">OR</code> condition (which had trouble using our existing set of indexes), we use <code class=\"language-text\">UNION</code> to combine the results matching each side of the <code class=\"language-text\">OR</code> clause.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> c<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span><span class=\"token punctuation\">,</span> l<span class=\"token punctuation\">.</span>distance <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> l<span class=\"token punctuation\">.</span>direction\n<span class=\"token keyword\">FROM</span> lineage l\n<span class=\"token keyword\">JOIN</span> commits c\n<span class=\"token keyword\">ON</span> c<span class=\"token punctuation\">.</span>repository <span class=\"token operator\">=</span> l<span class=\"token punctuation\">.</span>repository <span class=\"token operator\">AND</span> l<span class=\"token punctuation\">.</span>direction <span class=\"token operator\">=</span> <span class=\"token string\">'A'</span> <span class=\"token operator\">AND</span> c<span class=\"token punctuation\">.</span><span class=\"token string\">\"commit\"</span> <span class=\"token operator\">=</span> l<span class=\"token punctuation\">.</span>parent_commit\n\n<span class=\"token keyword\">UNION</span>\n\n<span class=\"token keyword\">SELECT</span> c<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span><span class=\"token punctuation\">,</span> l<span class=\"token punctuation\">.</span>distance <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> l<span class=\"token punctuation\">.</span>direction\n<span class=\"token keyword\">FROM</span> lineage l\n<span class=\"token keyword\">JOIN</span> commits c\n<span class=\"token keyword\">ON</span> c<span class=\"token punctuation\">.</span>repository <span class=\"token operator\">=</span> l<span class=\"token punctuation\">.</span>repository <span class=\"token operator\">AND</span> l<span class=\"token punctuation\">.</span>direction <span class=\"token operator\">=</span> <span class=\"token string\">'D'</span> <span class=\"token operator\">AND</span> c<span class=\"token punctuation\">.</span>parent_commit <span class=\"token operator\">=</span> l<span class=\"token punctuation\">.</span><span class=\"token string\">\"commit\"</span></code></pre></div>\n<p>The query plan for this new query, shown below, seems more complex at first glance. However, this query is <strong>drastically</strong> more efficient. The same input that required 330ms to evaluate now takes under 1ms to evaluate.</p>\n<figure>\n  <img src=\"https://sourcegraphstatic.com/blog/commit-graph-optimizations/super-fast.png\" alt=\"Super fast query plan\">\n  <figcaption>Query plan of an optimized commit graph traversal visiting 100 commits.</figcaption>\n</figure>\n<p>Even though we’re now executing a greater number of steps, each step can be evaluated efficiently. The old, inefficient index scan has been broken into 2 different index scans: one that traverses the ancestor direction, and another that traverses the descendant direction. The simple conditionals in each query can be evaluated <em>without an index filter</em> by each of the multicolumn indexes above. Instead of pulling back the entire commit graph on each iteration of the table expression, we pull exactly the set of rows that need to be added to the working table.</p>\n<p>This change makes the query efficient enough that we no longer have to worry about caching results, as running it on every request only contributes a negligible amount of time. Thus solving the problem <a href=\"https://www.youtube.com/watch?v=IjmtVKOAHPM\">once and for all</a>!</p>\n<p>Well, it solved the problem once and for all <em>at a particular scale</em>.</p>\n<h2 id=\"Lessons-learned\" style=\"position:relative;\"><a href=\"#Lessons-learned\" aria-label=\"Lessons learned permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Lessons learned</h2>\n<p>One major take away for us was the concrete reinforcement that databases are a hugely deep subject, but are not magic. Building and maintaining an accurate mental model of how your tools work seems to be a necessary skill in software engineering, and acting with poor mental models can lead to disastrous performance results (at best).</p>\n<p>Another major takeaway is that the cliché holds: computers do what you tell them to and nothing more. When debugging correctness and performance issues, it’s good to <em>shed</em> your previous mental model and re-assess its correctness as you dive deeper into your stack.</p>\n<p>Check out <a href=\"/blog/optimizing-a-code-intel-commit-graph-part-2/\">Part 2</a>, in which we tackle additional scalability challenges.</p>\n<h3 id=\"More-posts-like-this\" style=\"position:relative;\"><a href=\"#More-posts-like-this\" aria-label=\"More posts like this permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>More posts like this</h3>\n<ul>\n<li><a href=\"/blog/zoekt-memory-optimizations-for-sourcegraph-cloud/\">A 5x reduction in RAM usage with Zoekt memory optimizations</a></li>\n<li><a href=\"/blog/how-not-to-break-a-search-engine-unglamorous-engineering/\">How not to break a search engine or: What I learned about unglamorous engineering</a></li>\n<li><a href=\"/blog/avoiding-the-pitfalls-of-iteration-based-development/\">Avoiding the pitfalls of iteration-based development, explained in 5 pull requests</a></li>\n</ul>\n<style>\n  figure .no-shadow { box-shadow: none; }\n  .workingtable-highlight td { color: #ffffff; background-color: #005cb9; }\n\n  figcaption {\n    text-align: center;\n    margin-top: -2rem;\n    font-style: italic;\n  }\n</style>"}