{"expireTime":9007200905229171000,"key":"transformer-remark-markdown-html-c5dcf30d897f8fa049bfd2232db0bd17-gatsby-remark-autolink-headersgatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-unwrap-imagesgatsby-remark-imagesgatsby-remark-smartypants-","val":"<img src=\"https://storage.googleapis.com/sourcegraph-assets/blog/tackling-long-tail/tackling-the-long-tail-hero.png\" alt=\"Tackling the long tail of tiny repos with shard merging\">\n<p>In this post we give you a brief overview of how we’re tackling the long tail of tiny repositories by introducing shard\nmerging to Zoekt, in\nour <a href=\"https://about.sourcegraph.com/blog/why-index-the-oss-universe/\">quest to index the OSS universe</a>.</p>\n<h2 id=\"What-is-Zoekt\" style=\"position:relative;\"><a href=\"#What-is-Zoekt\" aria-label=\"What is Zoekt permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>What is Zoekt?</h2>\n<p><a href=\"https://github.com/sourcegraph/zoekt\">Zoekt</a> is a code search engine that\nperforms trigram-based regex search. Originally created by Han-Wen Niehuys, Zoekt is fast, easy to deploy, and easy to maintain, which makes it a great choice for\nour self-hosted customer deployments. <a href=\"https://about.sourcegraph.com/blog/sourcegraph-accepting-zoekt-maintainership/\">Sourcegraph is actually taking on maintainership of Zoekt, which you can read about here</a>.</p>\n<h2 id=\"Why-not-just-scale-out\" style=\"position:relative;\"><a href=\"#Why-not-just-scale-out\" aria-label=\"Why not just scale out permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Why not just scale out?</h2>\n<p>Naturally, Zoekt’s size of the index scales with the size of the input data. Zoekt’s index is about 2–3 times larger\nthan the input data. Some of that data, like the trigrams, is kept in memory. At the scale of the open source universe,\nit quickly becomes too costly to just scale out. Luckily, Zoekt still has a lot of untapped potential when it comes to\nmore efficient data structures. For example, in\na previous post, Ryan Hitchman\nexplained <a href=\"https://about.sourcegraph.com/blog/zoekt-memory-optimizations-for-sourcegraph-cloud/\">how we changed one of Zoekt’s core data structures to reduce memory by 5x</a>.</p>\n<p>The core idea of this project is to merge the long tail of small, stale repositories into more efficient representations\non disk and in memory. To understand the motivation behind this idea we have to first dive into Zoekt’s data model.</p>\n<h2 id=\"Zoekts-data-model\" style=\"position:relative;\"><a href=\"#Zoekts-data-model\" aria-label=\"Zoekts data model permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>Zoekt’s data model</h2>\n<p>Zoekt indexes repositories and stores the index in one or more files on disk. A repository contains a hierarchy of\ndocuments, such as source code, binaries, text files and so forth. At\nindex time <a href=\"https://sourcegraph.com/github.com/sourcegraph/zoekt@6a4adda25a6c5a7c6612e309249420102c587b4d/-/blob/gitindex/index.go?L498-505\">documents are added, one at a time, to the index builder</a>. Once we cross a threshold of input data, currently configured to be 100 MiB, the\nbuilder <a href=\"https://sourcegraph.com/github.com/sourcegraph/zoekt@6a4adda25a6c5a7c6612e309249420102c587b4d/-/blob/build/builder.go?L455-457\">flushes the index to a file on disk</a>. This file is called a shard. For small repositories, there is a 1:1 relationship between the repository and its shard.\nLarger repositories, such as <a href=\"https://sourcegraph.com/github.com/kubernetes/kubernetes\">Kubernetes</a> or the <a href=\"https://sourcegraph.com/github.com/torvalds/linux\">Linux Kernel</a> map to several shards. At query time, shards are treated independently.</p>\n<h2 id=\"The-long-tail\" style=\"position:relative;\"><a href=\"#The-long-tail\" aria-label=\"The long tail permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>The long tail</h2>\n<p>Most repositories are tiny and fit within a single shard. The following histogram shows the distribution of shard sizes\non one of our production instances.</p>\n<figure>\n  <img src=\"https://storage.googleapis.com/sourcegraph-assets/blog/tackling-long-tail/tackling-long-tail-histogram.png\" alt=\"Distribution of shard sizes\" class=\"no-shadow\">\n</figure>\n<p>75% of the shards in our sample are smaller than 2.1 MiB. Each shard contains, among other data, the trigrams we created\nduring indexing. On\nstartup, <a href=\"https://sourcegraph.com/github.com/sourcegraph/zoekt@6a4adda/-/blob/read.go?L210\">Zoekt loads those trigrams into memory</a>. Trigrams for content and file names make up more than 70% of the heap of Zoekt’s web server. The more unique trigrams a shard\nhas, the more costly its in-memory representation is.</p>\n<p>The two charts below show the number of trigrams in a shard vs. the shard’s size. Plot A shows that most shards have\nless than 500k trigrams. Plot B shows a subset of the data in A (red box).</p>\n<figure>\n  <img src=\"https://storage.googleapis.com/sourcegraph-assets/blog/tackling-long-tail/tackling-long-tail-trigrams.png\" alt=\"Number of trigrams vs. shard size\" class=\"no-shadow\">\n  <figcaption>Number of trigrams vs. shard size.</figcaption>\n</figure>\n<p>We can see that even tiny shards can have a lot of trigrams. As is to be expected, there is a positive correlation (the <a href=\"https://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient\">spearman correlation</a> is 0.94) but the\nslope is very small. Effectively, we are paying a premium for small shards as they take up a lot of memory per byte of\ninput data.</p>\n<p>The key insight is that there is a non-zero overlap between sets of trigrams from different shards. This presents a huge\nopportunity to save memory by merging small shards into much larger compound shards. Although the median\n<a href=\"https://en.wikipedia.org/wiki/Jaccard_index\">intersection-over-union</a> of two random shards in our sample is small (0.13), the overlap between a compound shard and another shard grows with every shard we merge. In other words, the\nlarger a compound is, the cheaper it is, in terms of memory, to merge it with a another shard.</p>\n<p>By merging several smaller shards, we are trading a smaller memory footprint for a potentially higher latency during\nsearch. We can fine-tune this trade-off with merge policies, for example by adjusting the target size of the compound\nshard and excluding some repositories from merging based on characteristics such as update frequency, rank, and\nrepository size. An obvious first choice is to merge those shards that are small, rarely accessed and rarely updated.</p>\n<p>The following diagram shows how the number of trigrams in a shard changes depending on how many repositories we merge into a compound shard.</p>\n<figure>\n  <img src=\"https://storage.googleapis.com/sourcegraph-assets/blog/tackling-long-tail/tackling-long-tail-compression.png\" alt=\"Number of trigrams vs. size of compound shard\" class=\"no-shadow\">\n</figure>\n<p>The distance between the two curves is a measure of the compression we can achieve.</p>\n<h2 id=\"Whats-next\" style=\"position:relative;\"><a href=\"#Whats-next\" aria-label=\"Whats next permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 18 95 120\" height=\"18\" width=\"18\"><path d=\"M53.69,78.7H37.94l-5.85,25H21.74l5.85-25H15.89L18,69.1H29.84l4.65-19.65H23.39l2.1-9.6H36.74l5.7-23.7H52.79l-5.7,23.7H62.84l5.7-23.7H78.89l-5.7,23.7H84.74l-2.4,9.6H70.94L66.29,69.1H77.24l-2.4,9.6H64l-5.85,25H47.84Zm-13.5-9.6H55.94l4.65-19.65H44.84Z\"/></svg></a>What’s next?</h2>\n<p>We are currently working on adding support for compound shards to Zoekt. First experiments indicate that we can expect\nan overall reduction in memory of about 50% for a target compound shard size of 2 GiB. We will make sure to follow up\nwith a blog post and the final numbers once the project concludes.</p>\n<style>\n  figure .no-shadow { box-shadow: none; }\n  .workingtable-highlight td { color: #ffffff; background-color: #005cb9; }\n\n  figcaption {\n    text-align: center;\n    margin-top: -2rem;\n    font-style: italic;\n  }\n</style>"}